<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
    
  
  <link href="https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />







  

<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css" rel="stylesheet" type="text/css" />



  

<link href="https://cdn.bootcss.com/social-share.js/1.0.9/css/share.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=1.0.0" rel="stylesheet" type="text/css" />



  <link rel="icon" type="image/png" sizes="32x32" href="/images/ganyuo.png?v=1.0.0">






  <meta name="keywords" content="Qt,C++," />










<meta name="description" content="先说两句&amp;emsp;&amp;emsp;最近偷懒了很久没有学习，对于自己的懒惰实在是看不下了，所以决定随便学点什么。但是最近没什么学习的方向，想起之前学过一点点Qt，但是没有学完，所有打算先把Qt学完，说不定以后能用上，随便记录一下学习笔记。我自己是一个自制力比较差的人，但是有点强迫症，如果了笔记没写完，会非常不舒服，所有以后以后把学的东西都记一下笔记，能一定程度上约束一下自己。突然想起之前写的shell">
<meta property="og:type" content="article">
<meta property="og:title" content="Qt 学习笔记">
<meta property="og:url" content="http://ganyuo.github.io/learn_note/qt_learn/index.html">
<meta property="og:site_name" content="ganyuo">
<meta property="og:description" content="先说两句&amp;emsp;&amp;emsp;最近偷懒了很久没有学习，对于自己的懒惰实在是看不下了，所以决定随便学点什么。但是最近没什么学习的方向，想起之前学过一点点Qt，但是没有学完，所有打算先把Qt学完，说不定以后能用上，随便记录一下学习笔记。我自己是一个自制力比较差的人，但是有点强迫症，如果了笔记没写完，会非常不舒服，所有以后以后把学的东西都记一下笔记，能一定程度上约束一下自己。突然想起之前写的shell">
<meta property="og:image" content="http://ganyuo.github.io/images/learn_note/qt_learn/fig_1.png">
<meta property="og:image" content="http://ganyuo.github.io/images/learn_note/qt_learn/fig_2.png">
<meta property="og:image" content="http://ganyuo.github.io/images/learn_note/qt_learn/fig_3.png">
<meta property="og:image" content="http://ganyuo.github.io/images/learn_note/qt_learn/fig_4.png">
<meta property="og:image" content="http://ganyuo.github.io/images/learn_note/qt_learn/fig_5.png">
<meta property="og:image" content="http://ganyuo.github.io/images/learn_note/qt_learn/fig_6.png">
<meta property="og:image" content="http://ganyuo.github.io/images/learn_note/qt_learn/fig_7.png">
<meta property="article:published_time" content="2023-03-10T16:00:00.000Z">
<meta property="article:modified_time" content="2024-12-06T08:46:06.680Z">
<meta property="article:author" content="ganyuo">
<meta property="article:tag" content="Qt">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ganyuo.github.io/images/learn_note/qt_learn/fig_1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '1.0.0',
    sidebar: {"position":"right","display":"always","offset":52,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    since: '2/1/2020 00:00:00',
    onlineAPI: '',
    site: {
      title: 'ganyuo',
      subtitle: '',
      author: 'ganyuo'
    },
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    leancloud: {
      enable: false,
      appID: '',
      appKey: ''
    },
    favicon: {
      visibilitychange: true,
      narmal: '/images/ganyuo.png',
      hidden: '/images/failure.ico',
      show_text: '(/≧▽≦/)欢迎回来！',
      hide_text: '(T﹏T)不要走嘛...'
    },
	load_to_main: false,
	img_mirror: {
      enable: false,
      prefix: 'https://cdn.jsdelivr.net/gh/ganyuo/ganyuo.github.io/'
	}
  };
</script>



  
    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>




  <link rel="canonical" href="http://ganyuo.github.io/learn_note/qt_learn/"/>



<script type="text/javascript">
	/* 自动跳转到主要内容部分（主页除外） */
	const custom_fun = {
		load_to_main: function () {
			var pathname = window.location.pathname;
			var pre_pathname = sessionStorage.getItem("pre_pathname");
			var cur_st = $(document).scrollTop();
			if (pathname != "/" && cur_st < 10 && pathname != pre_pathname) {
				$('html, body').animate({
					scrollTop: $("#main").offset().top - 50
				}, 500);
			}
			sessionStorage.setItem("pre_pathname", pathname);
		},

		use_img_mirror: function(prefix) {
			var imgs = document.getElementsByTagName("img");
			for(var i = 0; i < imgs.length; i++) {
				img_src = imgs[i].src;
				ind = img_src.indexOf("images");
				if(ind >= 0) {
					imgs[i].src = prefix + img_src.substring(ind);
				}
			}
		}
	}

	$(function () {
		if (window.CONFIG.load_to_main) {
			custom_fun.load_to_main();
		}
		if (window.CONFIG.img_mirror.enable) {
			custom_fun.use_img_mirror(window.CONFIG.img_mirror.prefix);
		}
	})
</script>



  <title>Qt 学习笔记 | ganyuo</title>
  








<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="ganyuo" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-后宫">
          <a href="/friends/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-mars"></i> <br />
            
            后宫
          </a>
        </li>
      
        
        <li class="menu-item menu-item-留言板">
          <a href="/message/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-pencil"></i> <br />
            
            留言板
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-rocket"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>


	<a href="https://github.com/ganyuo" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub">
	<svg width="100" height="100" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0; z-index: 4;" aria-hidden="true">
		<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
		<path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
		<path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
	</svg>
</a>
<style>
.github-corner:hover .octo-arm{
	animation:octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave{
	0%,100%{transform:rotate(0)}
	20%,60%{transform:rotate(-25deg)}
	40%,80%{transform:rotate(10deg)}
}
@media (max-width:500px){
	.github-corner:hover .octo-arm{
		animation:none
	}
	.github-corner .octo-arm{
		animation:octocat-wave 560ms ease-in-out
	}
}
</style>



<div class="site-brand-wrapper" >
  <div class="site-meta ">
    

      
        <p class="site-subtitle"></p>
      
  </div>
</div>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-date">
			<div class="post-month">03月</div>
			<div class="post-day">11</div>
	</div>
  
  <div class="post-badge">
    
      <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
        <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
          <span itemprop="name">学习笔记</span>
        </a>
      </span>
    
  </div>
  

  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ganyuo.github.io/learn_note/qt_learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ganyuo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ganyuo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ganyuo">
    </span>

    
      <header class="post-header">

        
        
          <p class="post-title" itemprop="name headline">Qt 学习笔记</p>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-03-11T00:00:00+08:00">
                2023-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">•</span>
            <span class="page-pv">本文总阅读数 <i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  11.8k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="先说两句"><a href="#先说两句" class="headerlink" title="先说两句"></a>先说两句</h1><p>&emsp;&emsp;最近偷懒了很久没有学习，对于自己的懒惰实在是看不下了，所以决定随便学点什么。但是最近没什么学习的方向，想起之前学过一点点Qt，但是没有学完，所有打算先把Qt学完，说不定以后能用上，随便记录一下学习笔记。我自己是一个自制力比较差的人，但是有点强迫症，如果了笔记没写完，会非常不舒服，所有以后以后把学的东西都记一下笔记，能一定程度上约束一下自己。突然想起之前写的shell脚本笔记还有<code>sed</code>命令还没学完，emmm…下次再补。</p>
<h1 id="Qt简介"><a href="#Qt简介" class="headerlink" title="Qt简介"></a>Qt简介</h1><p>&emsp;&emsp;Qt是一个跨平台的C++开发库，主要用来开发图形用户界面程序。Qt还存在Python、Ruby、Perl等脚本语言的绑定，也就是说可以使用脚本语言开发基于 Qt 的程序。开源社区就是这样，好东西就会被派生扩展，到处使用，越来越壮大。</p>
<p>&emsp;&emsp;Qt支持的操作系统有很多，例如通用操作系统Windows、Linux、Unix，智能手机系统Android、iOS、WinPhone，嵌入式系统QNX、VxWorks等等。</p>
<p>&emsp;&emsp;上面是从<a href="http://c.biancheng.net/view/1792.html" target="_blank" rel="noopener">C语言中文网</a>上抄的Qt简介，附上<a href="https://www.qt.io" target="_blank" rel="noopener">Qt的官网</a>，感兴趣的小伙伴可以去看看。</p>
<p>&emsp;&emsp;Qt包含很多C++的类，但是头文件代码里的注释基本没有，2333…，所以只能去看Qt官网上的文档：<a href="https://doc.qt.io/qt-5/classes.html" target="_blank" rel="noopener">https://doc.qt.io/qt-5/classes.html</a>，里面有所有类的说明。因为类太多了，所以后面关于类的成员函数就不解析了，小伙伴们有不清楚的地方可以去官网上查。</p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>&emsp;&emsp;我自己是在linuxmint系统下用VScode搭建的，具体参考这篇<a href="/learn_note/linux_qt_config/">博客</a>，其他系统下搭建环境的小伙伴也可以参考一下。</p>
<h1 id="pro文件配置"><a href="#pro文件配置" class="headerlink" title="pro文件配置"></a>pro文件配置</h1><p>&emsp;&emsp;pro文件只要用于配置Qt项目的编译，具体配置方式<del>抄</del>参考了一下大佬的这篇<a href="https://zhuanlan.zhihu.com/p/110782759" target="_blank" rel="noopener">文章</a></p>
<h2 id="常用配置项"><a href="#常用配置项" class="headerlink" title="常用配置项"></a>常用配置项</h2><ol>
<li><p>注释 : 注释是从一行的<code>#</code>开始，到这一行的结束。</p>
</li>
<li><p><code>QT +=</code> : 这个是添加QT项目需要的模块的，若项目中要排除某个模块，也可用<code>QT -=</code>配置项。</p>
</li>
<li><p><code>TEMPLATE =</code> : 这个配置项确定<code>qmake</code>为这个应用程序生成哪种<code>makefile</code> 。有下面五种形式可供选择：</p>
<ul>
<li><code>app</code> : 建立一个应用程序的makefile，这个是默认值，若模块项未指定，将默认使用此项；</li>
<li><code>lib</code> : 建立一个库的makefile；</li>
<li><code>vcapp</code> : 建立一个应用程序的VisualStudio项目文件；</li>
<li><code>vclib</code> : 建立一个库的VisualStudio项目文件；</li>
<li><code>subdirs</code> : 这是一个特殊的模板，可以创建一个可进入特定目录并为一个项目文件生成makefile，此makfile可以调用make；</li>
</ul>
</li>
<li><p><code>TARGET =</code>: 这个配置项用来指定最后生成的目标应用程序的名称。</p>
</li>
<li><p><code>CONFIG +=</code> : 用来告诉qmake关于应用程序的配置信息，使用+=表示在现有的配置上添加，这样会更安全。比如，<code>CONFIG += qt warn_on release</code> 其具体的意义为：</p>
<ul>
<li><code>qt</code> : 告诉qmake此程序是使用qt来连编的。即qmake在连接、为编译添加所需包含路径时会考虑qt的库；</li>
<li><code>warn_on</code> : 告诉qmake要将编译器设置为输出警告信息形式；</li>
<li><code>release</code> : 告诉qmake应用程序必须被连编为一个可发布的应用程序。开发过程中，也可以使用<code>debug</code>；</li>
</ul>
</li>
<li><p><code>UIC_DIR +=</code> : 用来指定<code>uic</code>命令，将<code>.ui</code>文件转化为<code>ui_*.h</code>文件存放的目录。</p>
</li>
<li><p><code>RCC_DIR +=</code> : 用来指定<code>rcc</code>命令，将<code>.qrc</code>文件转换成<code>qrc_*.h</code>文件存放的目录。</p>
</li>
<li><p><code>MOC_DIR +=</code> : 用来指定<code>moc</code>命令，将含有<code>Q_OBJECT</code>的头文件转换成标准<code>.h</code>文件存放的目录。</p>
</li>
<li><p><code>OBJECTS_DIR +=</code> : 用来指定目标文件<code>obj</code>的存放目录。</p>
</li>
<li><p><code>DEPENDPATH +=</code> : 用来指定工程的依赖路径。</p>
</li>
<li><p><code>INCLUDEPATH +=</code> : 用来指定工程所需要的头文件。</p>
</li>
<li><p><code>CODECFORSRC +=</code> : 用来指定源文件的编码格式。</p>
</li>
<li><p><code>FORMS +=</code> : 用来指定工程中的<code>ui</code>文件。</p>
</li>
<li><p><code>HEADERS +=</code> : 用来指定工程中所包含的头文件。</p>
</li>
<li><p><code>SOURCES +=</code> : 用来指定工程中包含的源文件。</p>
</li>
<li><p><code>RESOURCES +=</code> : 用来指定工程中所包含的资源文件。</p>
</li>
<li><p><code>LIBS +=</code> : 用来指定引入的<code>lib</code>文件的路径，一般会在前面加下参数<code>-L</code>，根据不同的版本可以分为两种形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Release: LIBS +&#x3D; -L folder_Path # release版本引入的lib文件</span><br><span class="line">Debug: LIBS +&#x3D; -L folder_Path   # debug版本引入的lib文件</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DEFINES +=</code> : 用来定义编译选项。</p>
</li>
<li><p><code>DESTDIR +=</code> : 用来指定目标的生成路径。</p>
</li>
<li><p>跨平台处理信息也要写在pro文件中。 其示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">win32</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unix</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="pro文件样例"><a href="#pro文件样例" class="headerlink" title="pro文件样例"></a>pro文件样例</h2><p>下面是大佬给的一个pro文件样例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># 添加QT依赖的库</span><br><span class="line">QT +&#x3D; gui</span><br><span class="line">QT +&#x3D; core xml network multimedia serialport</span><br><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT +&#x3D; widgets</span><br><span class="line"></span><br><span class="line"># 添加c11配置支持</span><br><span class="line">CONFIG +&#x3D; c++11</span><br><span class="line"># 输出文件的名称</span><br><span class="line">TARGET &#x3D; YouAppName</span><br><span class="line"># 配置控制台输出</span><br><span class="line">CONFIG +&#x3D; console</span><br><span class="line"># 输出类型application</span><br><span class="line">TEMPLATE &#x3D; app</span><br><span class="line"></span><br><span class="line"># 源文件</span><br><span class="line">SOURCES +&#x3D; main.cpp \</span><br><span class="line">    appconfig.cpp \</span><br><span class="line">    opendoorthread.cpp \</span><br><span class="line">    TestProject&#x2F;testform.cpp \</span><br><span class="line">    TestProject&#x2F;common.pb.cpp \</span><br><span class="line">    TestProject&#x2F;goods_req.pb.cpp \</span><br><span class="line">    TestProject&#x2F;goods_resp.pb.cpp</span><br><span class="line"></span><br><span class="line"># 头文件</span><br><span class="line">HEADERS +&#x3D; \</span><br><span class="line">    appconfig.h \</span><br><span class="line">    opendoorthread.h \</span><br><span class="line">    TestProject&#x2F;testform.h \</span><br><span class="line">    TestProject&#x2F;common.pb.h \</span><br><span class="line">    TestProject&#x2F;goods_req.pb.h \</span><br><span class="line">    TestProject&#x2F;goods_resp.pb.h</span><br><span class="line"></span><br><span class="line"># 配置debug和release</span><br><span class="line">CONFIG +&#x3D;debug_and_release</span><br><span class="line">CONFIG(debug,debug|release)&#123;</span><br><span class="line">DESTDIR +&#x3D; $$PWD&#x2F;debug</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lThorModel</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lThorUtil</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lThorBLL</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lThorHardwareUtil</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lprotobufd</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lprotobuf-lited</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lopencv_core2410d</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lopencv_highgui2410d</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lopencv_imgproc2410d</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lQtActionDetectd</span><br><span class="line">&#125;else&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 需要的头文件</span><br><span class="line">INCLUDEPATH +&#x3D; $$PWD&#x2F;AllDLL&#x2F;include</span><br><span class="line">INCLUDEPATH +&#x3D; $$PWD&#x2F;debug&#x2F;3rdparty&#x2F;opencv-2.4.10&#x2F;include \</span><br><span class="line">            $$PWD&#x2F;debug&#x2F;3rdparty&#x2F;opencv-2.4.10&#x2F;include&#x2F;opencv \</span><br><span class="line">            $$PWD&#x2F;debug&#x2F;3rdparty&#x2F;opencv-2.4.10&#x2F;include&#x2F;opencv2</span><br><span class="line"># ui</span><br><span class="line">FORMS +&#x3D; \</span><br><span class="line">    TestProject&#x2F;testform.ui</span><br></pre></td></tr></table></figure>

<h1 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h1><p>&emsp;&emsp;Qt的很多GUI控件都是继承自QWidget，所以使用Qt的GUI一般都需要加上<code>widgets</code>和<code>gui</code>这两个库，pro项目文件样例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 添加widgets和gui库</span><br><span class="line">QT +&#x3D; widgets gui</span><br><span class="line"></span><br><span class="line"># 把main.cpp加到项目的代码列表里</span><br><span class="line">SOURCES +&#x3D; \</span><br><span class="line">    main.cpp</span><br></pre></td></tr></table></figure>

<h2 id="QWidget"><a href="#QWidget" class="headerlink" title="QWidget"></a>QWidget</h2><p>&emsp;&emsp;QWidget是Qt的窗口类，下面是一段样例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt; /* 应用程序抽象类 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;  /* 窗口类 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>; <span class="comment">/* 创建一个Qt应用 */</span></span><br><span class="line"></span><br><span class="line">    QWidget widget; <span class="comment">/* 构造一个窗口 */</span></span><br><span class="line">    widget.setWindowTitle(<span class="string">"Hello World"</span>); <span class="comment">/* 设置窗口标题 */</span></span><br><span class="line">    widget.show(); <span class="comment">/* 显示窗口 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.exec(); <span class="comment">/* exec():进入消息循环 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面的代码中，创建了一个标题是<code>Hello World</code>的窗口。执行<code>app.exec();</code>后，会进入一个处理消息的死循环，<code>app</code>会捕获系统消息，并传递给<code>widget</code>窗口。这就是鼠标点击后能拖动窗口的原因，<code>app</code>将鼠标的点击、移动等消息传递给了<code>widget</code>，<code>widget</code>作出了对应的响应，窗口移动了位置。</p>
<h2 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h2><p>&emsp;&emsp;Qt里有很多控件，大部分都是继承自<code>Qwidget</code>，所以控件也可以看作是一个窗口，这里列举一些常用的控件(抄大佬的这篇<a href="https://zhuanlan.zhihu.com/p/612560027" target="_blank" rel="noopener">博客</a>)：</p>
<table>
<thead>
<tr>
<th>控件</th>
<th>类名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>标签</td>
<td>QLabel</td>
<td>显示一个文本或图像。</td>
</tr>
<tr>
<td>按钮</td>
<td>QPushButton</td>
<td>用户可以点击的一个按钮，用来触发某个操作。</td>
</tr>
<tr>
<td>输入框</td>
<td>QLineEdit</td>
<td>用户可以在其中输入文本的一个输入框。</td>
</tr>
<tr>
<td>复选框</td>
<td>QCheckBox</td>
<td>用户可以勾选或取消的一个复选框。</td>
</tr>
<tr>
<td>单选按钮</td>
<td>QRadioButton</td>
<td>用户可以选择其中一个选项的一组单选按钮。</td>
</tr>
<tr>
<td>数字微调框</td>
<td>QSpinBox</td>
<td>用于选择一个数值的微调框。</td>
</tr>
<tr>
<td>滑动条</td>
<td>QSlider</td>
<td>用户可以通过滑动来选择数值的一个滑动条。</td>
</tr>
<tr>
<td>列表框</td>
<td>QListWidget</td>
<td>用于显示一组列表项的一个列表框。</td>
</tr>
<tr>
<td>组合框</td>
<td>QComboBox</td>
<td>类似于下拉菜单的一个组合框，用户可以选择其中一个选项。</td>
</tr>
<tr>
<td>多行文本框</td>
<td>QTextEdit</td>
<td>用户可以在其中编辑多行文本的一个文本编辑框。</td>
</tr>
<tr>
<td>日期和时间编辑框</td>
<td>QDateTimeEdit</td>
<td>用于选择日期和时间的一个日期和时间编辑框。</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;由于控件种类太多了，这里只介绍一下按钮<code>QPushButton</code>和输入框<code>QLineEdit</code>这两种控件，其他控件的很多性质和接口都比较相似，小伙伴们可以自己尝试，<del>我就偷懒不写了</del>。</p>
<h3 id="按钮-QPushButton"><a href="#按钮-QPushButton" class="headerlink" title="按钮-QPushButton"></a>按钮-QPushButton</h3><p>&emsp;&emsp;下面是一个在窗口中添加一个按钮的样例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt; /* 应用程序抽象类 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;  /* 窗口类 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt; /* 按钮类 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget widget; <span class="comment">/* 构造一个窗口 */</span></span><br><span class="line">    widget.show(); <span class="comment">/* 显示窗口 */</span></span><br><span class="line"></span><br><span class="line">    QPushButton button; <span class="comment">/* 创建一个按钮对象 */</span></span><br><span class="line">    button.setText(<span class="string">"Button"</span>); <span class="comment">/* 设置按钮显示的文本 */</span></span><br><span class="line">    button.setParent(&amp;widget); <span class="comment">/* 设置按钮的父窗口 */</span></span><br><span class="line">    button.show(); <span class="comment">/* 显示按钮 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.exec(); <span class="comment">/* exec():进入消息循环 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面的代码会创建一个窗口，窗口中包含一个按钮。在Qt中，<code>QPushButton</code>是<code>QWidget</code>的子类，所以按钮也可以看作是一个窗口。</p>
<p>&emsp;&emsp;Qt里的窗口可以存在父子关系，上面的代码中，<code>button.setParent(&amp;widget);</code>的作用是将<code>button</code>按钮的父窗口设置成<code>widget</code>，设置后<code>button</code>按钮才会显示在<code>widget</code>窗口里面；如果不设置，<code>button</code>按钮会显示成一个独立的窗口，与<code>widget</code>窗口同级。</p>
<p>&emsp;&emsp;一个窗口在执行<code>show()</code>成员函数时，会将已经添加的子窗口也一起显示，如果是子窗口是在父窗口执行<code>show()</code>之后添加的，则子窗口不会显示，子窗口也需要执行<code>show()</code>才能显示出来。比如，去掉上面代码中的<code>button.show()</code>之后，虽然之后将<code>button</code>按钮添加到了父窗口<code>widget</code>里，但是<code>widget</code>窗口里的<code>button</code>按钮不显示。如果在<code>widget</code>窗口执行<code>show()</code>之前，将<code>button</code>按钮添加到了父窗口<code>widget</code>里，也就是在<code>widget.show()</code>之前执行<code>button.setParent(&amp;widget)</code>，则即使<code>button</code>按钮不执行<code>show()</code>，也会在父窗口<code>widget</code>执行<code>show()</code>的时候一起显示出来。</p>
<h3 id="输入框-QLineEdit"><a href="#输入框-QLineEdit" class="headerlink" title="输入框-QLineEdit"></a>输入框-QLineEdit</h3><p>&emsp;&emsp;下面是一个输入框的样例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt; /* 应用程序抽象类 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;      /* 窗口类 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLineEdit&gt;    /* 输入框 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCompleter&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QWidget widget; <span class="comment">/* 构造一个窗口 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加两个输入框 */</span></span><br><span class="line">    QLineEdit name_input, password_input;</span><br><span class="line">    <span class="function">QVBoxLayout <span class="title">layout</span><span class="params">(&amp;widget)</span></span>;</span><br><span class="line">    layout.addWidget(&amp;name_input);</span><br><span class="line">    layout.addWidget(&amp;password_input);</span><br><span class="line"></span><br><span class="line">    <span class="function">QCompleter <span class="title">completer</span><span class="params">(QStringList() &lt;&lt; <span class="string">"abc"</span> &lt;&lt; <span class="string">"aaa"</span> &lt;&lt; <span class="string">"123"</span>)</span></span>;</span><br><span class="line">    completer.setFilterMode(Qt::MatchContains);</span><br><span class="line">    name_input.setCompleter(&amp;completer); <span class="comment">/* 设置输入匹配提示 */</span></span><br><span class="line">    name_input.setPlaceholderText(<span class="string">"请用户名"</span>); <span class="comment">/* 设置输入提示 */</span></span><br><span class="line"></span><br><span class="line">    password_input.setEchoMode(QLineEdit::Password); <span class="comment">/* 设置回显模式为密码模式 */</span></span><br><span class="line">    password_input.setPlaceholderText(<span class="string">"请输入密码"</span>); <span class="comment">/* 设置输入提示 */</span></span><br><span class="line"></span><br><span class="line">    widget.show(); <span class="comment">/* 显示窗口 */</span></span><br><span class="line">    <span class="keyword">return</span> app.exec(); <span class="comment">/* exec():进入消息循环 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面的代码向窗口中添加了两个输入框，一个用来输入用户名，一个用来输入密码。用户名输入框设置了一个<code>completer</code>，可以将输入的字符串与<code>completer</code>的字符串列表进行匹配，显示匹配成功的字符串。密码输入框设置了设置回显模式为密码模式，可以将输入的字符显示为<code>●</code>。</p>
<h2 id="坐标体系"><a href="#坐标体系" class="headerlink" title="坐标体系"></a>坐标体系</h2><p>&emsp;&emsp;Qt里的<code>Qwidget</code>可以使用<code>setGeometry()</code>来设置控件的位置坐标，位置坐标是相对与父窗口的左上角计算的，下面是一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QWidget widget;</span><br><span class="line">QPushButton button;</span><br><span class="line">button.setText(<span class="string">"Button"</span>);</span><br><span class="line">button.setParent(&amp;widget);</span><br><span class="line"><span class="comment">/* 设置button相对父窗口的坐标ax,ay，以及button的宽度aw和高度ah */</span></span><br><span class="line">button.setGeometry(<span class="number">30</span>, <span class="number">30</span>, <span class="number">200</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面的例子中，<code>setGeometry()</code>有4个参数，前两个参数是<code>button</code>相对父窗口的坐标ax，ay，后面两个是<code>button</code>的宽度和高度aw，ah。</p>
<h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><p>&emsp;&emsp;当一个窗口里控件很多时，使用<code>setGeometry()</code>来设置很麻烦，而且无法随着窗口的大小变化而调整。使用layout(布局)就可以很方便的解决这个问题，他们负责一组控件的几何管理。上面<a href="../../../../../downloads/qt_learn.md#输入框-QLineEdit">输入框-QLineEdit</a>里的样例代码，使用的<code>QVBoxLayout</code>就是一种layout，可以将控件在垂直方向上排列，使得<code>name_input</code>输入框在<code>password_input</code>输入框上面，如果不使用layout，则两个输入框会重叠在一起。(以下内容大部分抄的大佬的这篇<a href="https://blog.csdn.net/leacock1991/article/details/118947828" target="_blank" rel="noopener">博客</a>)</p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>&emsp;&emsp;Qt布局系统提供了一种简单而强大的方法，可以在控件内自动排列子控件，以确保它们充分利用可用空间。Qt包含一组布局管理类，用于描述控件在应用程序用户界面中的布局方式。当控件的可用空间发生变化时，这些layout会自动定位和调整控件的大小，确保它们的排列一致并且用户界面作为一个整体仍然可用。</p>
<p>&emsp;&emsp;所有<code>QWidget</code>子类都可以使用layout来管理它们的子类。<code>QWidget::setLayout()</code>函数可以为一个控件设置layout。 当以这种方式在窗口上设置layout时，它负责以下任务：</p>
<ul>
<li>布置子控件。</li>
<li>最高层窗口可感知的默认大小。</li>
<li>最高层窗口可感知的最小大小。</li>
<li>调整大小的处理。</li>
<li>当内容改变的时候自动更新：<ul>
<li>字体大小、文本或者子控件的其它内容。</li>
<li>隐藏或者显示子控件。</li>
<li>移除一些子控件。</li>
</ul>
</li>
</ul>
<h3 id="常用layout"><a href="#常用layout" class="headerlink" title="常用layout"></a>常用layout</h3><p>&emsp;&emsp;为控件提供良好布局的最简单方法是使用Qt内置的布局管理器：<code>QHBoxLayout</code>、<code>QVBoxLayout</code>、<code>QGridLayout</code>和<code>QFormLayout</code>。这些类从<code>QLayout</code>继承，而<code>QLayout</code>又从<code>QObject</code>（而不是<code>QWidget</code>）派生。他们负责一组控件的几何管理。要创建更复杂的布局，可以将布局管理器相互嵌套。</p>
<ul>
<li><p><code>QHBoxLayout</code>：从左到右在水平行中布置控件。</p>
<p>  <img src="/images/learn_note/qt_learn/fig_1.png" alt=""></p>
</li>
<li><p><code>QVBoxLayout</code>：在垂直列中从上到下布置控件。</p>
<p>  <img src="/images/learn_note/qt_learn/fig_2.png" alt=""></p>
</li>
<li><p><code>QGridLayout</code>：在二维网格中布置控件，控件可以占用多个单元格。</p>
<p>  <img src="/images/learn_note/qt_learn/fig_3.png" alt=""></p>
</li>
<li><p><code>QFormLayout</code>：把控件按照标签-输入框的形式排列在两列。</p>
<p>  <img src="/images/learn_note/qt_learn/fig_4.png" alt=""></p>
</li>
</ul>
<h3 id="为layout添加控件"><a href="#为layout添加控件" class="headerlink" title="为layout添加控件"></a>为layout添加控件</h3><p>&emsp;&emsp;将控件添加到一个layout时，布局过程如下：</p>
<ol>
<li>所有控件最初将根据它们的<code>QWidget::sizePolicy()</code>和<code>QWidget::sizeHint()</code>分配一定数量的空间。</li>
<li>如果任何控件设置了拉伸系数，并且其值大于零，那么它们将按其拉伸因子的比例分配空间（如下<a href="../../../../../downloads/qt_learn.md#伸展因素">伸展因素</a>所述）。</li>
<li>如果任何控件的拉伸系数设置为零，它们只会在没有其他控件需要空间的情况下获得更多空间。其中，空间首先分配给具有扩展大小策略的控件。</li>
<li>任何控件被分配的空间的大小如果小于它们的最小大小（如果未指定最小尺寸，则为最小尺寸提示），它们就会被按它们所需要的最小大小分配空间。（如果控件的伸展因素是它们的决定因素，它们不必有最小大小或者最小大小的提示。）</li>
<li>任何控件被分配的空间的大小如果大于它们的最大大小，它们就会被按它们所需要的最大大小分配空间。（如果控件的伸展因素是它们的决定因素，它们不必有最大大小。）</li>
</ol>
<h3 id="伸展因素"><a href="#伸展因素" class="headerlink" title="伸展因素"></a>伸展因素</h3><p>&emsp;&emsp;控件通常是在没有伸展因素设置的情况下被生成的。当它们被布置到一个layout中时，控件会被根据它们的<code>QWidget::sizePolicy()</code>或者它们的最小大小的提示中大的那一个分配给整个空间的一部分。伸展因素是用来根据控件互相的比例来改变它们所被分配的空间。</p>
<p>&emsp;&emsp;如果使用一个<code>QHBoxLayout</code>来布置没有伸展参数设置的三个控件，则我们就会得到像下面这样的布局：</p>
<p><img src="/images/learn_note/qt_learn/fig_5.png" alt=""></p>
<p>&emsp;&emsp;如果我们给每个控件设置一个伸展因素，它们就会被按比例布置（但是不能小于最小大小的提示），以下是按1:3:2设置的：</p>
<p><img src="/images/learn_note/qt_learn/fig_6.png" alt=""></p>
<h3 id="简单的demo"><a href="#简单的demo" class="headerlink" title="简单的demo"></a>简单的demo</h3><p>&emsp;&emsp;布局中常用的方法有<code>addWidget()</code>和<code>addLayout()</code>，<code>addWidget()</code>方法用于向layout中加入需要布局的控件，<code>addLayout()</code>方法用于向layout中加入子布局。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addWidget</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    QWidget *widget, <span class="comment">// 需要插入的控件对象</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> fromRow,     <span class="comment">// 插入的行</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> fromColumn,  <span class="comment">// 插入的列</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> rowSpan,     <span class="comment">// 占用的行</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> columnSpan,  <span class="comment">// 占用的列数</span></span></span></span><br><span class="line"><span class="function"><span class="params">    Qt::Alignment alignment = Qt::Alignment <span class="comment">// 各个控件的对齐方式</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    QLayout *layout, <span class="comment">// 需要插入的子布局对象</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> row,         <span class="comment">// 插入的起始行</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> column,      <span class="comment">// 插入的起始列</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> rowSpan,     <span class="comment">// 占用的行数</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> columnSpan,  <span class="comment">// 占用的列数</span></span></span></span><br><span class="line"><span class="function"><span class="params">    Qt::Alignment alignment = Qt::Alignment <span class="comment">// 指定的对齐方式</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下面是一个样例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QVBoxLayout&gt; /* 垂直布局 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QHBoxLayout&gt; /* 水平布局 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QGridLayout&gt; /* 格子布局 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QWidget widget;</span><br><span class="line"></span><br><span class="line">    QGridLayout layout;            <span class="comment">// 创建格子布局</span></span><br><span class="line">    layout.setRowStretch(<span class="number">0</span>, <span class="number">1</span>);    <span class="comment">// 设置第0行的拉伸系数</span></span><br><span class="line">    layout.setColumnStretch(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 设置第0列的拉伸系数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向layout中添加控件 */</span></span><br><span class="line">    layout.addWidget(<span class="keyword">new</span> QLabel(<span class="string">"用户名："</span>), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    layout.addWidget(<span class="keyword">new</span> QLineEdit(), <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    layout.addWidget(<span class="keyword">new</span> QLabel(<span class="string">"密码："</span>), <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    layout.addWidget(<span class="keyword">new</span> QLineEdit(), <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向layout中添加子布局 */</span></span><br><span class="line">    QHBoxLayout hbox;</span><br><span class="line">    hbox.addStretch(<span class="number">1</span>);  <span class="comment">// 添加伸缩量</span></span><br><span class="line">    hbox.addWidget(<span class="keyword">new</span> QPushButton(<span class="string">"登录"</span>));</span><br><span class="line">    layout.addLayout(&amp;hbox, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    layout.setRowStretch(<span class="number">4</span>, <span class="number">1</span>);    <span class="comment">// 设置最后一行的拉伸系数</span></span><br><span class="line">    layout.setColumnStretch(<span class="number">3</span>, <span class="number">1</span>); <span class="comment">// 设置最后一列的拉伸系数</span></span><br><span class="line"></span><br><span class="line">    widget.setLayout(&amp;layout); <span class="comment">// 给窗口设置layout</span></span><br><span class="line">    widget.show();</span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="画板"><a href="#画板" class="headerlink" title="画板"></a>画板</h2><p>&emsp;&emsp;抄了大佬的这篇<a href="https://zhuanlan.zhihu.com/p/638570663" target="_blank" rel="noopener">博客</a>。</p>
<p>&emsp;&emsp;<code>QPainter</code>是 Qt 中用于进行绘图操作的类。它提供了各种绘制函数，可以在不同的绘图设备上进行绘制，如窗口、图像、打印机等。</p>
<p>以下是<code>QPainter</code>类的一些常用属性和方法：</p>
<ul>
<li><code>begin(QPaintDevice *device)</code>: 在给定的绘图设备上开始绘制操作。</li>
<li><code>end()</code>: 结束绘制操作。</li>
<li><code>drawText(const QRectF &amp;rectangle, const QString &amp;text)</code>: 绘制指定矩形区域内的文本。</li>
<li><code>drawImage(const QRectF &amp;target, const QImage &amp;image, const QRectF &amp;source)</code>: 在目标矩形区域内绘制源图像的一部分。</li>
<li><code>setPen(const QPen &amp;pen)</code>: 设置绘制的画笔样式。</li>
<li><code>setBrush(const QBrush &amp;brush)</code>: 设置绘制的画刷样式。</li>
<li><code>setFont(const QFont &amp;font)</code>: 设置绘制的字体样式。</li>
<li><code>translate(const QPointF &amp;offset)</code>: 将绘图坐标原点平移指定的偏移量。</li>
<li><code>scale(qreal sx, qreal sy)</code>: 沿着x轴和y轴方向对绘图进行缩放。</li>
<li><code>rotate(qreal angle)</code>: 以原点为中心，按照给定的角度旋转绘图。</li>
<li><code>save()</code>: 保存当前的绘图状态，包括画笔、画刷、字体等设置。</li>
<li><code>restore()</code>: 恢复上一次保存的绘图状态。</li>
</ul>
<p>&emsp;&emsp;这些方法和属性只是<code>QPainter</code>类的一部分，还有其他许多功能可以用于绘制不同的图形和效果。可以根据需要在<code>QPainter</code>文档中进一步了解更多细节。</p>
<p>&emsp;&emsp;下面是一个简单的示例，演示了如何使用<code>QPainter</code>在窗口上进行绘制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPixmap&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_painter</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    my_painter() &#123;&#125;;</span><br><span class="line">    ~my_painter() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *e)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_painter::paintEvent</span><span class="params">(QPaintEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 消锯齿 */</span></span><br><span class="line">    painter.setRenderHint(QPainter::Antialiasing);</span><br><span class="line">    <span class="comment">/* 设置画笔，线条为红色，线宽为2，使用虚线 */</span></span><br><span class="line">    painter.setPen(QPen(Qt::red , <span class="number">2</span>, Qt::DashLine));</span><br><span class="line">    <span class="comment">/* 设置画刷，当画矩形等封闭图形时，用黄色填充 */</span></span><br><span class="line">    painter.setBrush(Qt::yellow);</span><br><span class="line">    <span class="comment">/* 设置字体，楷体，大小为40，700加粗，斜体 */</span></span><br><span class="line">    painter.setFont(QFont(<span class="string">"楷体"</span>, <span class="number">40</span>, <span class="number">700</span>, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 画直线 */</span></span><br><span class="line">    painter.drawLine(<span class="number">20</span>, <span class="number">40</span>, <span class="number">200</span>, <span class="number">40</span>);</span><br><span class="line">    <span class="comment">/* 画圆 */</span></span><br><span class="line">    painter.drawEllipse(QPoint(<span class="number">100</span>, <span class="number">120</span>), <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="comment">/* 写字 */</span></span><br><span class="line">    painter.drawText(QPoint(<span class="number">20</span>, <span class="number">240</span>), <span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向左移动400 */</span></span><br><span class="line">    painter.translate(<span class="number">400</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 画图片 */</span></span><br><span class="line">    painter.drawPixmap(QPoint(<span class="number">0</span>, <span class="number">20</span>), QPixmap(<span class="string">"./image/滑稽.png"</span>));</span><br><span class="line">    <span class="comment">// /* 画矩形 */</span></span><br><span class="line">    painter.drawRect(QRect(<span class="number">0</span>, <span class="number">120</span>, <span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">    <span class="comment">// /* 画圆角矩形 */</span></span><br><span class="line">    painter.drawRoundedRect(QRect(<span class="number">0</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">50</span>), <span class="number">15</span>, <span class="number">15</span>, Qt::AbsoluteSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">	my_painter widget;</span><br><span class="line">	widget.show();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在上述示例中，我们创建了一个自定义的<code>QWidget</code>派生类<code>my_painter</code>，并重写了<code>paintEvent()</code>函数。在<code>paintEvent()</code>函数中，我们创建了一个<code>QPainter</code>对象，将其关联到窗口上，并使用一些绘制函数，在窗口的矩形区域内绘制图形。最后，我们创建了一个<code>my_painter</code>对象并显示窗口，绘制的图形将在窗口中心显示。运行的结果如下：</p>
<p><img src="/images/learn_note/qt_learn/fig_7.png" alt=""></p>
<p>&emsp;&emsp;这只是一个简单的示例，你可以根据需要使用其他绘图函数和属性来绘制更复杂的图形和效果。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>&emsp;&emsp;抄了大佬的这篇<a href="https://blog.csdn.net/qq_29912325/article/details/117767972" target="_blank" rel="noopener">博客</a></p>
<h3 id="事件定义"><a href="#事件定义" class="headerlink" title="事件定义"></a>事件定义</h3><p>&emsp;&emsp;事件(event)是由系统或者 Qt 本身在不同的时刻发出的。当用户按下鼠标，敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件是在对用户操作做出响应的时候发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。</p>
<h3 id="事件与信号槽"><a href="#事件与信号槽" class="headerlink" title="事件与信号槽"></a>事件与信号槽</h3><p>&emsp;&emsp;一般来说，使用 Qt 编程时，我们并不会把主要精力放在事件上，因为在 Qt 中，需要我们关心的事件总会发出一个信号。比如，我们关心的是<code>QPushButton</code>的鼠标点击，但我们不需要关心这个鼠标点击事件，而是关心它的<code>clicked()</code>信号。</p>
<ul>
<li><strong>信号槽</strong>：<code>signal</code>由具体对象发出，然后会马上交给由<code>connect</code>函数连接的<code>slot</code>进行处理。</li>
<li><strong>事件</strong>：Qt 使用一个事件队列对所有发出的事件进行维护，当新的事件产生时，会被追加到事件队列的尾部，前一个事件完成后，取出后面的事件进行处理。但是，必要的时候，Qt 的事件也是可以不进入事件队列，而是直接处理的。并且，事件还可以使用“事件过滤器”进行过滤。</li>
</ul>
<p>&emsp;&emsp;总的来说，如果我们使用组件，我们关心的是信号槽；如果我们自定义组件，我们关心的是事件。因为我们可以通过事件来改变组件的默认操作。比如，如果我们要自定义一个<code>QPushButton</code>，那么我们就需要重写它的鼠标点击事件和键盘处理事件，并且在恰当的时候发出<code>clicked()</code>信号。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>&emsp;&emsp;我们在 main 函数里面创建了一个<code>QApplication</code>对象，然后调用了它的<code>exec()</code>函数。其实，这个函数就是开始 Qt 的事件循环。在执行<code>exec()</code>函数之后，程序将进入事件循环来监听应用程序的事件。</p>
<h3 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h3><p>&emsp;&emsp;当事件发生时，Qt 将创建一个事件对象。Qt 的所有事件都继承于<code>QEvent</code>类。在事件对象创建完毕后，Qt 将这个事件对象传递给 QObject 的<code>event()</code>函数。<code>event()</code>函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数(event handler) 。</p>
<p>&emsp;&emsp;例如在所有组件的父类 QWidget 中，定义了很多事件处理函数 ，如<code>keyPressEvent()</code>、<code>keyReleaseEvent()</code>、<code>mouseDoubleClickEvent()</code>、<code>mouseMoveEvent ()</code>、<code>mousePressEvent()</code>、<code>mouseReleaseEvent()</code>等。这些函数都是<code>protected virtual</code>的，也就是说，我们应该在子类中重写这些函数。下面是一个重写事件处理函数的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMouseEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QKeyEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">event_widget</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">/* 事件处理主函数，主要用来截取事件 */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">event</span><span class="params">(QEvent *ev)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 鼠标按下事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *ev)</span></span>;</span><br><span class="line">    <span class="comment">/* 鼠标释放事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *ev)</span></span>;</span><br><span class="line">    <span class="comment">/* 鼠标移动事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *ev)</span></span>;</span><br><span class="line">    <span class="comment">/* 鼠标双击事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mouseDoubleClickEvent</span><span class="params">(QMouseEvent *ev)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 键盘按下事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent *ev)</span></span>;</span><br><span class="line">    <span class="comment">/* 键盘释放事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">keyReleaseEvent</span><span class="params">(QKeyEvent *ev)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 窗口隐藏事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hideEvent</span><span class="params">(QHideEvent *ev)</span></span>;</span><br><span class="line">    <span class="comment">/* 窗口显示事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showEvent</span><span class="params">(QShowEvent *ev)</span></span>;</span><br><span class="line">    <span class="comment">/* 重绘事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *ev)</span></span>;</span><br><span class="line">    <span class="comment">/* 窗口关闭事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">closeEvent</span><span class="params">(QCloseEvent *ev)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事件处理主函数，主要用于事件的分发 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">event_widget::event</span><span class="params">(QEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 默认的事件处理函数 */</span></span><br><span class="line">    <span class="keyword">return</span> QWidget::event(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鼠标按下事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::mousePressEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"mouse press event"</span>;</span><br><span class="line">    QWidget::mousePressEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鼠标释放事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::mouseReleaseEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"mouse release event"</span>;</span><br><span class="line">    QWidget::mouseReleaseEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鼠标移动事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::mouseMoveEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 只有鼠标按下时移动，才能触发事件 */</span></span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"mouse move "</span> &lt;&lt; i++;</span><br><span class="line">    <span class="comment">/* 如果要在鼠标不按下时，也触发事件，需要在构造函数中运行下面的代码 */</span></span><br><span class="line">    <span class="comment">// this-&gt;setMouseTracking(true);</span></span><br><span class="line">    QWidget::mouseMoveEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鼠标双击事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::mouseDoubleClickEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"mouse double click event"</span>;</span><br><span class="line">    QWidget::mouseDoubleClickEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 键盘按下事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::keyPressEvent</span><span class="params">(QKeyEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"key press event "</span> &lt;&lt; ev-&gt;key();</span><br><span class="line">    QWidget::keyPressEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 键盘释放事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::keyReleaseEvent</span><span class="params">(QKeyEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"key release event "</span> &lt;&lt; ev-&gt;key();</span><br><span class="line">    QWidget::keyPressEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 窗口隐藏事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::hideEvent</span><span class="params">(QHideEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"hide event"</span>;</span><br><span class="line">    QWidget::hideEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 窗口显示事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::showEvent</span><span class="params">(QShowEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"show event"</span>;</span><br><span class="line">    QWidget::showEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重绘事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::paintEvent</span><span class="params">(QPaintEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"paint event"</span>;</span><br><span class="line">    QWidget::paintEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 窗口关闭事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::closeEvent</span><span class="params">(QCloseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"close event"</span>;</span><br><span class="line">    QWidget::closeEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    event_widget widget;</span><br><span class="line">    widget.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们定义了一个<code>QWidget</code>的子类<code>event_widget</code>，重写了一些事件处理函数。</p>
<h3 id="事件接受与忽略"><a href="#事件接受与忽略" class="headerlink" title="事件接受与忽略"></a>事件接受与忽略</h3><p>&emsp;&emsp;前面的例子中我们在重写事件处理函数时，都会调用父类对应的事件处理函数。这在某种程度上说，是把事件向上传递给父类去响应，也就是说，我们在子类中“忽略”了这个事件。</p>
<p>&emsp;&emsp;我们可以把 Qt 的事件传递看成链状：如果子类没有处理这个事件，就会继续向其他类传递。其实，Qt 的事件对象都有一个<code>accept()</code>函数和<code>ignore()</code>函数。正如它们的名字，前者用来告诉 Qt，事件处理函数“接收”了这个事件，不要再传递；后者则告诉 Qt，事件处理函数“忽略”了这个事件，需要继续传递，寻找另外的接受者。在事件处理函数中，可以使用<code>isAccepted()</code>来查询这个事件是不是已经被接收了。</p>
<p>&emsp;&emsp;事实上，我们很少使用<code>accept()</code>和<code>ignore()</code>函数，而是像上面的示例一样，如果希望忽略事件，只要调用父类的响应函数即可。</p>
<p>&emsp;&emsp;Qt 中的事件大部分是<code>protected</code>的，因此，重写的函数必定存在着其父类中的响应函数，这个方法是可行的。为什么要这么做呢？因为我们无法确认父类中的这个处理函数没有操作，如果我们在子类中直接忽略事件，Qt 不会再去寻找其他的接受者，那么父类的操作也就不能进行，这可能会有潜在的危险。</p>
<p>&emsp;&emsp;在一个情形下，我们必须使用<code>accept()</code>和<code>ignore()</code>函数，那就是在窗口关闭的时候。如果在窗口关闭时需要有个询问对话框，那么就需要这么去写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 窗口关闭事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::closeEvent</span><span class="params">(QCloseEvent * event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QMessageBox::StandardButton ret;</span><br><span class="line">    ret = QMessageBox::question(<span class="keyword">this</span>, <span class="string">"Quit"</span>,</span><br><span class="line">        <span class="string">"Are you sure to quit this application"</span>,</span><br><span class="line">        QMessageBox::Yes | QMessageBox::No, QMessageBox::No);</span><br><span class="line">    <span class="keyword">if</span>(ret == QMessageBox::Yes) &#123;</span><br><span class="line">        event-&gt;accept();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event-&gt;ignore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们经过询问之后才能正常退出程序。</p>
<h3 id="event-函数"><a href="#event-函数" class="headerlink" title="event()函数"></a>event()函数</h3><p>&emsp;&emsp;事件对象创建完毕后，Qt 将这个事件对象传递给<code>QObject</code>的<code>event()</code>函数。<code>event()</code>函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器(event handler)。</p>
<p>&emsp;&emsp;<code>event()</code>函数主要用于事件的分发，所以，如果希望在事件分发之前做一些操作，那么，就需要注意这个<code>event()</code>函数了。为了达到这种目的，我们可以重写<code>event()</code>函数。</p>
<p>&emsp;&emsp;例如，如果希望在窗口中的 tab 键按下时将焦点移动到下一组件，而不是让具有焦点的组件处理，那么就可以继承 QWidget ，并重写它的<code>event()</code>函数，以达到这个目的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MyWidget::event</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;type() == QEvent::KeyPress)</span><br><span class="line">    &#123;</span><br><span class="line">        QKeyEvent *keyEvent = <span class="keyword">static_cast</span>&lt;QKeyEvent *&gt;(event);</span><br><span class="line">        <span class="keyword">if</span> (keyEvent-&gt;key() == Qt::Key_Tab)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理 Tab 键时事件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::event(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>event()</code>函数接受一个 QEvent 对象，也就是需要这个函数进行转发的对象。为了进行转发，必定需要有一系列的类型判断，这就可以调用 QEvent 的<code>type()</code>函数，其返回值是<code>QEvent::Type</code>类型的枚举。</p>
<p>&emsp;&emsp;我们处理过自己需要的事件后，可以直接<code>return</code>回去，对于其他我们不关心的事件，需要调用父类的<code>event()</code>函数继续转发，否则这个组件就只能处理我们定义的事件了。</p>
<p>&emsp;&emsp;<code>event()</code>函数返回值是<code>bool</code>类型，如果传入的事件已被识别并且处理，返回<code>true</code>，否则返回<code>false</code>。如果返回值是<code>true</code>，QApplication 会认为这个事件已经处理完毕，会继续处理事件队列中的下一事件；如果返回值是<code>false</code>，QApplication 会尝试寻找这个事件的下一个处理函数。</p>
<p>&emsp;&emsp;<code>event()</code>函数的返回值和事件的<code>accept()</code>和<code>ignore()</code>函数不同。<code>accept()</code>和<code>ignore()</code>函数用于不同的事件处理器之间的沟通，例如判断这一事件是否处理；<code>event()</code>函数的返回值主要是通知 QApplication 的<code>notify()</code>函数是否处理下一事件。</p>
<p>为了更加明晰这一点，我们来看看 QWidget 的<code>event()</code>函数是如何定义的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QWidget::event</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (e-&gt;type())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> QEvent::KeyPress:</span><br><span class="line">            keyPressEvent((QKeyEvent *)event);</span><br><span class="line">            <span class="keyword">if</span> (!((QKeyEvent *)event)-&gt;isAccepted())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QEvent::KeyRelease:</span><br><span class="line">            keyReleaseEvent((QKeyEvent *)event);</span><br><span class="line">            <span class="keyword">if</span> (!((QKeyEvent *)event)-&gt;isAccepted())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// more...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;QWidget 的<code>event()</code>函数使用一个巨大的 switch 来判断 QEvent 的 type，并且分发给不同的事件处理函数。在事件处理函数之后，使用这个事件的<code>isAccepted()</code>方法，获知这个事件是不是被接受，如果没有被接受则<code>event()</code>函数立即返回<code>false</code>，否则返回<code>true</code>。</p>
<p>&emsp;&emsp;另外一个必须重写<code>event()</code>函数的情形是有自定义事件的时候。如果程序中有自定义事件，则必须重写<code>event()</code>函数以便将自定义事件进行分发，否则自定义事件永远也不会被调用。</p>
<h3 id="事件过滤器"><a href="#事件过滤器" class="headerlink" title="事件过滤器"></a>事件过滤器</h3><p>&emsp;&emsp;Qt 创建了 QEvent 事件对象之后，会调用 QObject 的<code>event()</code>函数做事件的分发。有时候，可能需要在调用event()函数之前做一些另外的操作，比如，对话框上某些组件可能并不需要响应回车按下的事件，此时，就需要重新定义组件的<code>event()</code>函数。如果组件很多，就需要重写很多次<code>event()</code>函数，这显然没有效率。为此，可以使用一个事件过滤器，来判断是否需要调用<code>event()</code>函数。</p>
<p>QOjbect 有一个<code>eventFilter()</code>函数，用于建立事件过滤器。这个函数的签名如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">QObject::eventFilter</span><span class="params">(QObject * watched, QEvent * event)</span></span></span><br></pre></td></tr></table></figure>

<p>如果 watched 对象安装了事件过滤器，这个函数会被调用并进行事件过滤，然后才轮到组件进行事件处理。在重写这个函数时，如果需要过滤掉某个事件，例如停止对这个事件的响应，需要返回true。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 重载消息过滤器 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">event_filter_t::eventFilter</span><span class="params">(QObject *o, QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;type() == QEvent::MouseButtonPress ||</span><br><span class="line">        e-&gt;type() == QEvent::MouseButtonRelease ||</span><br><span class="line">        e-&gt;type() == QEvent::MouseButtonDblClick)</span><br><span class="line">    &#123;</span><br><span class="line">		QPushButton *button = <span class="keyword">static_cast</span>&lt;QPushButton *&gt;(o);</span><br><span class="line">        qDebug() &lt;&lt; button-&gt;text() &lt;&lt; <span class="string">"button mouse event"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QObject::eventFilter(o, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面的例子中为 event_filter_t 建立了一个事件过滤器。为了过滤某个组件上的事件，首先需要判断这个对象是哪个组件，然后判断这个事件的类型。</p>
<p>&emsp;&emsp;例如，我不想让 textEdit 组件处理键盘事件，于是就首先找到这个组件，如果这个事件是键盘事件，则直接返回<code>true</code>，也就是过滤掉了这个事件。对于其他组件，我们并不保证是不是还有过滤器，于是最保险的办法是调用父类的函数。</p>
<p>&emsp;&emsp;在创建了过滤器之后，下面要做的是安装这个过滤器。安装过滤器需要调用<code>installEventFilter()</code>函数。这个函数的签名如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QObject::installEventFilter</span><span class="params">(QObject* filterObj)</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个函数是 QObject 的一个函数，因此可以安装到任何 QObject 的子类，并不仅仅是 UI 组件。这个函数接收一个 QObject 对象，调用了这个函数安装事件过滤器的组件会调用 filterObj 定义的<code>eventFilter()</code>函数。</p>
<p>&emsp;&emsp;例如，<code>textField.installEventFilter(obj)</code>，则如果有事件发送到 textField 组件是，会先调用<code>obj-&gt;eventFilter()</code>函数，然后才会调用<code>textField.event()</code>。</p>
<p>&emsp;&emsp;当然，你也可以把事件过滤器安装到 QApplication 上面，这样就可以过滤所有的事件，已获得更大的控制权。不过，这样做的后果就是会降低事件分发的效率。</p>
<p>&emsp;&emsp;如果一个组件安装了多个过滤器，则最后一个安装的会最先调用，类似于堆栈的行为。</p>
<p>&emsp;&emsp;<strong>注意</strong>：如果你在事件过滤器中<code>delete</code>了某个接收组件，务必将返回值设为<code>true</code>。否则，Qt 还是会将事件分发给这个接收组件，从而导致程序崩溃。</p>
<p>&emsp;&emsp;事件过滤器和被安装的组件必须在同一线程，否则，过滤器不起作用。另外，如果在 install 之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</p>
<p>&emsp;&emsp;事件的调用最终都会调用 QCoreApplication 的<code>notify()</code>函数，因此，最大的控制权实际上是重写 QCoreApplication 的<code>notify()</code>函数。由此可以看出，Qt 的事件处理实际上是分层五个层次：</p>
<ol>
<li>重定义事件处理函数</li>
<li>重定义 event()函数</li>
<li>为单个组件安装事件过滤器</li>
<li>为 QApplication 安装事件过滤器</li>
<li>重定义 QCoreApplication 的<code>notify()</code>函数</li>
</ol>
<p>这几个层次的控制权是逐层增大的。</p>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>&emsp;&emsp;Qt 允许创建自己的事件类型，这在多线程的程序中尤其有用，当然，也可以用在单线程的程序中，作为一种对象间通讯的机制。那么，为什么需要使用事件，而不是使用信号槽呢？主要原因是，事件的分发既可以是同步的，又可以是异步的，而函数的调用或者说是槽的回调总是同步的。事件的另外一个好处是，它可以使用过滤器。</p>
<p>&emsp;&emsp;Qt 中的自定义事件很简单，同其他类似的库的使用很相似，都是要继承一个类进行扩展。在 Qt 中，你需要继承的类是<code>QEvent</code>。</p>
<p>&emsp;&emsp;继承 QEvent 类，你需要提供一个<code>QEvent::Type</code>类型的参数，作为自定义事件的类型值。这里的 QEvent::Type 类型是 QEvent 里面定义的一个 enum，因此，你是可以传递一个 int 的。重要的是，你的事件类型不能和已经存在的 type 值重复，否则会有不可预料的错误发生！因为系统会将你的事件当做系统事件进行派发和调用。</p>
<p>&emsp;&emsp;在 Qt 中，系统将保留<code>0 - 999</code>的值，也就是说，你的事件 type 要大于999. 具体来说，你的自定义事件的 type 要在 QEvent::User 和 QEvent::MaxUser 的范围之间。其中，QEvent::User 值是1000，QEvent::MaxUser 的值是65535。从这里知道，你最多可以定义64536个事件，相信这个数字已经足够大了！</p>
<p>&emsp;&emsp;但是，即便如此，也只能保证用户自定义事件不能覆盖系统事件，并不能保证自定义事件之间不会被覆盖。为了解决这个问题，Qt 提供了一个函数：<code>registerEventType()</code>，用于自定义事件的注册。该函数签名如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">QEvent::registerEventType</span><span class="params">(<span class="keyword">int</span> hint = <span class="number">-1</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数是 static 的，因此可以使用 QEvent 类直接调用。函数接受一个 int 值，其默认值为-1，返回值是创建的这个 Type 类型的值。如果 hint 是合法的，不会发生任何覆盖，则会返回这个值；如果hint不合法，系统会自动分配一个合法值并返回。因此，使用这个函数即可完成 type 值的指定。这个函数是线程安全的，因此不必另外添加同步。</p>
<p>&emsp;&emsp;你可以在 QEvent 子类中添加自己的事件所需要的数据，然后进行事件的发送。Qt 中提供了两种发送方式：</p>
<p><code>static bool QCoreApplication::sendEvent(QObjecy receiver, QEvent event)</code>：事件被<br>QCoreApplication 的 notify()函数直接发送给 receiver 对象，返回值是事件处理函数的返回值。使用这个函数必须要在栈上创建事件对象，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMouseEvent <span class="title">event</span><span class="params">(QEvent::MouseButtonPress, pos, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">QApplication::sendEvent(mainWindow, &amp;event);</span><br></pre></td></tr></table></figure>

<p><code>static bool QCoreApplication::postEvent(QObject receiver, QEvent event)</code>：事件被<br>QCoreApplication 追加到事件列表的最后，并等待处理，该函数将事件追加后会立即返回，并且注意，该函数是线程安全的。另外一点是，使用这个函数必须要在堆上创建对象，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QApplication::postEvent(object, <span class="keyword">new</span> MyEvent(QEvent::registerEventType(<span class="number">2048</span>)));</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个对象不需要手动 delete，Qt 会自动 delete 掉！因此，如果在 post 事件之后调用 delete，程序可能会崩溃。另外，postEvent()函数还有一个重载的版本，增加一个优先级参数，具体请参见API。通过调用 sendPostedEvent()函数可以让已提交的事件立即得到处理。</p>
<p>&emsp;&emsp;如果要处理自定义事件，可以重写 QObject 的<code>customEvent()</code>函数，该函数接收一个 QEvent 对象作为参数，也可以像前面介绍的重写<code>event()</code>函数的方法去重写这个函数，这两种办法都是可行的。下面是一个使用自定义信号的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化自定义的事件类型值 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> CUSTOM_EVENT_TYPE = QEvent::registerEventType();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义事件类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">custom_event_t</span> :</span> <span class="keyword">public</span> QEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">custom_event_t</span>() : QEvent((QEvent::Type)CUSTOM_EVENT_TYPE) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">main_widgt_t</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">main_widgt_t</span>() : QWidget() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">event</span><span class="params">(QEvent *e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">customEvent</span><span class="params">(QEvent *e)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重载事件处理函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">main_widgt_t::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e-&gt;type() == CUSTOM_EVENT_TYPE)</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"event() get custom event\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QObject::event(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重载自定义事件处理函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main_widgt_t::customEvent</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e-&gt;type() == CUSTOM_EVENT_TYPE)</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"customEvent() get custom event\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">	<span class="keyword">main_widgt_t</span> main_w;</span><br><span class="line"></span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"CUSTOM_EVENT_TYPE: "</span> &lt;&lt; CUSTOM_EVENT_TYPE;</span><br><span class="line"></span><br><span class="line">	<span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">"send custom event"</span>)</span></span>;</span><br><span class="line">	button.setParent(&amp;main_w);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使用lambda表达式连接button的点击事件 */</span></span><br><span class="line">	QObject::connect(&amp;button, &amp;QPushButton::clicked, [&amp;main_w]()</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">custom_event_t</span> custom_event;</span><br><span class="line">        <span class="comment">/* 给main_w发送自定义事件 */</span></span><br><span class="line">        QApplication::sendEvent(&amp;main_w, &amp;custom_event);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	main_w.show();</span><br><span class="line">	<span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h2><p>&emsp;&emsp;抄了大佬的这篇<a href="https://zhuanlan.zhihu.com/p/648165514" target="_blank" rel="noopener">博客</a>。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;信号槽是QT中用于对象间通信的一种机制，也是QT的核心机制。在GUI编程中，我们经常需要在改变一个组件的同时，通知另一个组件做出响应。</p>
<p>&emsp;&emsp;早期，对象间的通信采用回调来实现。回调实际上是利用函数指针来实现，当我们希望某件事发生时处理函数能够获得通知，就需要将回调函数的指针传递给处理函数，这样处理函数就会在合适的时候调用回调函数。回调有两个明显的缺点：</p>
<ul>
<li>它们不是类型安全的，我们无法保证处理函数传递给回调函数的参数都是正确的。</li>
<li>回调函数和处理函数紧密耦合，源于处理函数必须知道哪一个函数被回调。</li>
</ul>
<p>&emsp;&emsp;在QT中，我们有回调技术之外的选择，也即是信号槽机制。所谓的信号与槽，其实都是函数。当特定事件被触发时将发送一个信号，而与该信号建立的连接槽，则可以接收到该信号并做出反应。</p>
<p>&emsp;&emsp;QT组件预定义了很多信号和槽，而在GUI编程中，我们习惯于继承那些组件，继承后添加我们自己的槽，以便以我们的方式来处理信号。槽和普通的C++成员函数几乎是一样的，它可以是虚函数，可以被重载，可以是共有、私有或是保护的，也同样可以被其他成员函数调用。它的函数参数也可以是任意类型的。唯一不同的是：槽还可以和信号连接在一起。</p>
<p>&emsp;&emsp;与回调不同，信号槽机制是类型安全的。这体现在信号的函数签名与槽的函数签名必须匹配上，才能够发生信号的传递。实际上，槽的参数个数可以比信号的参数个数少，因为槽能够忽略信号形参中多出来的参数。信号和槽是松耦合的：发出信号的类不关心哪些类将接收它的信号。QT的槽能够接收到信号的参数并调用，信号和槽都可以有任意个数的参数，它们都是类型安全的。</p>
<h3 id="样例分析"><a href="#样例分析" class="headerlink" title="样例分析"></a>样例分析</h3><p>&emsp;&emsp;首先我们要知道的是，所有继承自<code>QObject</code>或者它的子类（如<code>QWidget</code>）都可以包含信号槽。我们写的类也要继承自<code>QObject</code>（或其子类）。所有包含了信号槽的类都必须在声明的上部含有<code>Q_OBJECT</code>宏。</p>
<p>一个基于<code>QObject</code>的信号类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MY_SIGHNAL_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MY_SIGHNAL_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_signal</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    my_signal() : QObject() &#123;&#125;;</span><br><span class="line">    ~my_signal() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __MY_SIGHNAL_H__ */</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在这个信号类中，我们使用Qt的<code>signals</code>关键字定义了一个信号函数<code>signal_fun()</code>，这个信号函数不需要开发人员来实现，需要用Qt的moc工具来实现。</p>
<p>&emsp;&emsp;Signal的代码会由 moc 自动生成，开发人员一定不能在自己的C++代码中实现它。反之，槽应该由编程人员来实现，下面提供MyStr::setVaule()的一种可能实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"MyStr.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyStr::setValue</span><span class="params">(QString value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value != m_value)</span><br><span class="line">    &#123;</span><br><span class="line">        m_value = value;</span><br><span class="line">        <span class="function">emit <span class="title">valueChanged</span><span class="params">(value)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;setValue函数首先比较新参的值与数据成员的值是否是一样的（后面有解释为何这样做），如果不是，则设置好数据成员m_value的值，然后，把信号valueChanged（）发送出去。发送给谁？类并没有写，这并不是类设计者所关心的，也不是类所关心的，它只管把信号发送出去就行。然后，我们再来设置谁来接收这个信号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyStr a;</span><br><span class="line">    MyStr b;</span><br><span class="line">    QObject::connect(&amp;a,SIGNAL(valueChanged(QString)),&amp;b,SLOT(setValue(QString)));</span><br><span class="line">    a.setValue(<span class="string">"this is A"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们定义了两个类对象a/b，使用 QObject::connect（）函数指定了发送方、信号、接收方、槽等信息，connect函数的格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect(<span class="comment">/*发送方*/</span>, SIGNAL(), <span class="comment">/*接收方*/</span>, SLOT());</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当我们调用a的成员函数setValue时，该函数除了把a.m_value设置为”this is A”，也把信号valueChanged()发送出去，被b.setValue所接收，从而，把b.m_value设置为”this is A”，同时b.setValue又把valueChanged信号发射出去，然而该信号并没有对象接收，因为我们没有建立以b为发送方的任何连接。此时你应该明白，为何在emit前需要判断value != m_value，因为如果没有此步骤，且恰巧设置了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect(&amp;b,SIGNAL(valueChanged(QString)),&amp;a,SLOT(setValue(QString)));</span><br></pre></td></tr></table></figure>

<p>则b的信号被a接收，a又发送信号被b接收，如此进入死循环。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"> </span><br><span class="line">    MyStr  a;</span><br><span class="line">    MyStr  b;</span><br><span class="line">    QObject::connect(&amp;a,SIGNAL(valueChanged(QString)),&amp;b,SLOT(setValue(QString)));</span><br><span class="line">    a.setValue(<span class="string">"this is A"</span>);</span><br><span class="line"> </span><br><span class="line">    QLabel* label = <span class="keyword">new</span> QLabel;</span><br><span class="line">    label-&gt;setText( b.value());</span><br><span class="line">    label-&gt;show();</span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们使用label输出来看看b是否接收到a的信号，如果是，则b的内容应该是”this is A”，输出在label上，程序运行结果：</p>
<p>&emsp;&emsp;这个例子展示了对象之间通信的一种方式。对象间可以一起工作，而不需要知道彼此的任何信息。为了达到通信的目的，只需要将它们连接起来，而这只需要通过 调用 QObject::connect() 函数指定一些简单信息就好。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>要把信号成功连接到槽，它们的参数必须具有相同的顺序和相同的类型，或者允许信号的参数比槽多，槽会自动忽略掉多出来的参数而进行调用。</p>
<h4 id="一个信号可以连接多个槽"><a href="#一个信号可以连接多个槽" class="headerlink" title="一个信号可以连接多个槽"></a>一个信号可以连接多个槽</h4><p>&emsp;&emsp;使用QObject::connect可以把一个信号连接到多个槽，而当信号发射时，将按声明联系时的顺序依次调用槽。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyStr  a;</span><br><span class="line"> MyStr  b;</span><br><span class="line"> MyStr  c;</span><br><span class="line"><span class="comment">//信号连接到两个槽</span></span><br><span class="line"> QObject::connect(&amp;a,SIGNAL(valueChanged(QString)),&amp;b,SLOT(setValue(QString)));</span><br><span class="line"> QObject::connect(&amp;a,SIGNAL(valueChanged(QString)),&amp;c,SLOT(setValue(QString)));</span><br><span class="line"> a.setValue(<span class="string">"this is A"</span>);</span><br><span class="line"><span class="comment">//依次调用b.setValue()、c.setValue()</span></span><br></pre></td></tr></table></figure>

<h4 id="多个信号可以连接同一个槽"><a href="#多个信号可以连接同一个槽" class="headerlink" title="多个信号可以连接同一个槽"></a>多个信号可以连接同一个槽</h4><p>&emsp;&emsp;同样的，可以让多个信号连接到同一个槽上 ，而且其中的每一个信号的发送，都会调用了那个槽。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyStr  a;</span><br><span class="line"> MyStr  b;</span><br><span class="line"> MyStr  c;</span><br><span class="line"><span class="comment">//两个信号连接到同一个槽</span></span><br><span class="line"> QObject::connect(&amp;a,SIGNAL(valueChanged(QString)),&amp;c,SLOT(setValue(QString)));</span><br><span class="line"> QObject::connect(&amp;b,SIGNAL(valueChanged(QString)),&amp;c,SLOT(setValue(QString)));</span><br><span class="line"><span class="comment">//下面的操作皆会调用到槽c.setValue()</span></span><br><span class="line"> a.setValue(<span class="string">"this is A"</span>);</span><br><span class="line">b.setValue(<span class="string">"this is B"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="一个信号可以和另外一个信号相连接"><a href="#一个信号可以和另外一个信号相连接" class="headerlink" title="一个信号可以和另外一个信号相连接"></a>一个信号可以和另外一个信号相连接</h4><p>&emsp;&emsp;当发射第一个信号的时候，也会把第二个信号一个发送出去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyStr  a;</span><br><span class="line"> MyStr  b;</span><br><span class="line"> MyStr  c;</span><br><span class="line"><span class="comment">//两个信号相连接</span></span><br><span class="line"> QObject::connect(&amp;a,SIGNAL(valueChanged(QString)),&amp;b,SIGNAL(valueChanged(QString)));</span><br><span class="line"><span class="comment">//再建立b与c的连接</span></span><br><span class="line"> QObject::connect(&amp;b,SIGNAL(valueChanged(QString)),&amp;c,SLOT(setValue(QString)));</span><br><span class="line"><span class="comment">//下面的操作同时发送了信号a.valueChanged与b.valueChanged</span></span><br><span class="line"> a.setValue(<span class="string">"this is A"</span>);</span><br><span class="line"><span class="comment">//从而信号b.valueChanged被槽c.setValue所接收</span></span><br></pre></td></tr></table></figure>

<h4 id="连接可以被移除"><a href="#连接可以被移除" class="headerlink" title="连接可以被移除"></a>连接可以被移除</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除b 与 c之间的连接</span></span><br><span class="line">  QObject::disconnect(&amp;b,SIGNAL(valueChanged(QString)),&amp;c,SLOT(setValue(QString)));</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;实际上当对象被delete时，其关联的所有链接都会失效，QT会自动移除和这个对象的所有链接。</p>

      
    </div>
    
    
    
    
    

    
	  <hr>
      <div class="post-share">分享到：</div>
    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Qt/" rel="tag"># Qt</a>
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/learn_note/huffman_tree/" rel="next" title="哈夫曼树">
                <i class="fa fa-chevron-left"></i> 哈夫曼树
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="waline"></div>
    </div>
  





  




	





  





  












    <script src="https://unpkg.com/@waline/client@v2/dist/waline.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"/>
    <script>
        Waline.init({
            el: '#waline',
            serverURL: 'https://waline-test-11aslqzru-ganyuo-outlookcom.vercel.app',
            emoji: [
                '//unpkg.com/@waline/emojis@1.0.1/qq',
                '//unpkg.com/@waline/emojis@1.0.1/weibo',
                '//unpkg.com/@waline/emojis@1.0.1/bilibili',
            ],
        });
    </script>
    <style>
        /*设置 Waline 的主题色*/
        :root{
            --waline-bgcolor: #fff0;
            --waline-bgcolor-light: #fff0;
        }
        .wl-panel
        {
            margin: 2em;
        }
        .wl-count
        {
            padding: 0em 2em 0em 2em;
        }
        .wl-power
        {
            padding: .5em 2em;
        }
        .wl-emoji-popup .wl-tab-wrapper {
            background: #FFF;
            max-height: 125px;
        }
    </style>




        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/ganyuo.png"
                alt="ganyuo" />
            
              <p class="site-author-name" itemprop="name">ganyuo's blog</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/ganyuo" target="_blank" title="GitHub" data-balloon="GitHub" data-balloon-pos="up">
                    
                      <i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto://ganyuo@outlook.com" target="_blank" title="Mail" data-balloon="Mail" data-balloon-pos="up">
                    
                      <i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
            
          </div>

          

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            
            

          </nav>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#先说两句"><span class="nav-number">1.</span> <span class="nav-text">先说两句</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Qt简介"><span class="nav-number">2.</span> <span class="nav-text">Qt简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#环境搭建"><span class="nav-number">3.</span> <span class="nav-text">环境搭建</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#pro文件配置"><span class="nav-number">4.</span> <span class="nav-text">pro文件配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常用配置项"><span class="nav-number">4.1.</span> <span class="nav-text">常用配置项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pro文件样例"><span class="nav-number">4.2.</span> <span class="nav-text">pro文件样例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GUI"><span class="nav-number">5.</span> <span class="nav-text">GUI</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#QWidget"><span class="nav-number">5.1.</span> <span class="nav-text">QWidget</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控件"><span class="nav-number">5.2.</span> <span class="nav-text">控件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#按钮-QPushButton"><span class="nav-number">5.2.1.</span> <span class="nav-text">按钮-QPushButton</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入框-QLineEdit"><span class="nav-number">5.2.2.</span> <span class="nav-text">输入框-QLineEdit</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#坐标体系"><span class="nav-number">5.3.</span> <span class="nav-text">坐标体系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#layout"><span class="nav-number">5.4.</span> <span class="nav-text">layout</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简述"><span class="nav-number">5.4.1.</span> <span class="nav-text">简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用layout"><span class="nav-number">5.4.2.</span> <span class="nav-text">常用layout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为layout添加控件"><span class="nav-number">5.4.3.</span> <span class="nav-text">为layout添加控件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伸展因素"><span class="nav-number">5.4.4.</span> <span class="nav-text">伸展因素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单的demo"><span class="nav-number">5.4.5.</span> <span class="nav-text">简单的demo</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#画板"><span class="nav-number">5.5.</span> <span class="nav-text">画板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件"><span class="nav-number">5.6.</span> <span class="nav-text">事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事件定义"><span class="nav-number">5.6.1.</span> <span class="nav-text">事件定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件与信号槽"><span class="nav-number">5.6.2.</span> <span class="nav-text">事件与信号槽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件循环"><span class="nav-number">5.6.3.</span> <span class="nav-text">事件循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件处理函数"><span class="nav-number">5.6.4.</span> <span class="nav-text">事件处理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件接受与忽略"><span class="nav-number">5.6.5.</span> <span class="nav-text">事件接受与忽略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#event-函数"><span class="nav-number">5.6.6.</span> <span class="nav-text">event()函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件过滤器"><span class="nav-number">5.6.7.</span> <span class="nav-text">事件过滤器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义事件"><span class="nav-number">5.6.8.</span> <span class="nav-text">自定义事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号和槽"><span class="nav-number">5.7.</span> <span class="nav-text">信号和槽</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简介"><span class="nav-number">5.7.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#样例分析"><span class="nav-number">5.7.2.</span> <span class="nav-text">样例分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接"><span class="nav-number">5.7.3.</span> <span class="nav-text">连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一个信号可以连接多个槽"><span class="nav-number">5.7.3.1.</span> <span class="nav-text">一个信号可以连接多个槽</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多个信号可以连接同一个槽"><span class="nav-number">5.7.3.2.</span> <span class="nav-text">多个信号可以连接同一个槽</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个信号可以和另外一个信号相连接"><span class="nav-number">5.7.3.3.</span> <span class="nav-text">一个信号可以和另外一个信号相连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#连接可以被移除"><span class="nav-number">5.7.3.4.</span> <span class="nav-text">连接可以被移除</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <!--<div class="footer-image"></div>-->
      <div class="footer-inner">
        <p>
小破站在各种灾难中苟活了
	<span id="since"></span>
	<span class="my-face">o(╥﹏╥)o</span>
	<a href="/atom.xml" target="_blank">RSS</a>
</p>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数 <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量 <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

	<img class="background-image" src="https://ganyuo.github.io/images/backgound_1.jpg" />

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

	
		<div class="live2d-container">
	<div class="live2d-tips"></div>
	<canvas id="live2d-canvas" height="380" style="width:300px;" ></canvas>
	<div class="live2d-tools">
		<i class="fa fa-commenting"></i>
		<i class="fa fa-chevron-down"></i>
		<i class="fa fa-chevron-up"></i>
	</div>
</div>

<script type="text/javascript" src="/js/live2d.js"></script>
<script type="text/javascript" src="/js/live2d_tools.js"></script>
<script>
	loadlive2d('live2d-canvas', "/images/live2d_model/nepnep/index.json");
</script>

	

    

  </div>

  <script type="text/javascript" src="/js/sagiri.min.js"></script>

  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('2');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  


  

  

</body>
</html>
