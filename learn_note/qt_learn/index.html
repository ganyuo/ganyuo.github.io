<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
    
  
  <link href="https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />







  

<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css" rel="stylesheet" type="text/css" />



  

<link href="https://cdn.bootcss.com/social-share.js/1.0.9/css/share.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css" rel="stylesheet" type="text/css" />



  <link rel="icon" type="image/png" sizes="32x32" href="/images/ganyuo.png">






  <meta name="keywords" content="Qt,C++," />










<meta name="description" content="先说两句   最近偷懒了很久没有学习，对于自己的懒惰实在是看不下了，所以决定随便学点什么。但是最近没什么学习的方向，想起之前学过一点点Qt，但是没有学完，所有打算先把Qt学完，说不定以后能用上，随便记录一下学习笔记。我自己是一个自制力比较差的人，但是有点强迫症，如果了笔记没写完，会非常不舒服，所有以后以后把学的东西都记一下笔记，能一定程度上约束一下自己。突然想起之前写的shell脚本笔记还有se">
<meta property="og:type" content="article">
<meta property="og:title" content="Qt 学习笔记">
<meta property="og:url" content="http://ganyuo.github.io/learn_note/qt_learn/index.html">
<meta property="og:site_name" content="ganyuo">
<meta property="og:description" content="先说两句   最近偷懒了很久没有学习，对于自己的懒惰实在是看不下了，所以决定随便学点什么。但是最近没什么学习的方向，想起之前学过一点点Qt，但是没有学完，所有打算先把Qt学完，说不定以后能用上，随便记录一下学习笔记。我自己是一个自制力比较差的人，但是有点强迫症，如果了笔记没写完，会非常不舒服，所有以后以后把学的东西都记一下笔记，能一定程度上约束一下自己。突然想起之前写的shell脚本笔记还有se">
<meta property="og:image" content="http://ganyuo.github.io/images/learn_note/qt_learn/fig_1.png">
<meta property="og:image" content="http://ganyuo.github.io/images/learn_note/qt_learn/fig_2.png">
<meta property="og:image" content="http://ganyuo.github.io/images/learn_note/qt_learn/fig_3.png">
<meta property="og:image" content="http://ganyuo.github.io/images/learn_note/qt_learn/fig_4.png">
<meta property="og:image" content="http://ganyuo.github.io/images/learn_note/qt_learn/fig_5.png">
<meta property="og:image" content="http://ganyuo.github.io/images/learn_note/qt_learn/fig_6.png">
<meta property="og:image" content="http://ganyuo.github.io/images/learn_note/qt_learn/fig_8.png">
<meta property="og:image" content="http://ganyuo.github.io/images/learn_note/qt_learn/fig_7.png">
<meta property="article:published_time" content="2023-03-10T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-07T01:58:02.802Z">
<meta property="article:author" content="ganyuo">
<meta property="article:tag" content="Qt">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ganyuo.github.io/images/learn_note/qt_learn/fig_1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '1.0.0',
    sidebar: {"position":"right","display":"always","offset":52,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    since: '2/1/2020 00:00:00',
    onlineAPI: '',
    site: {
      title: 'ganyuo',
      subtitle: '',
      author: 'ganyuo'
    },
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    leancloud: {
      enable: false,
      appID: '',
      appKey: ''
    },
    favicon: {
      visibilitychange: true,
      narmal: '/images/ganyuo.png',
      hidden: '/images/failure.ico',
      show_text: '(/≧▽≦/)欢迎回来！',
      hide_text: '(T﹏T)不要走嘛...'
    },
	load_to_main: false,
	img_mirror: {
      enable: false,
      prefix: 'https://cdn.jsdelivr.net/gh/ganyuo/ganyuo.github.io/'
	}
  };
</script>



  
    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>




  <link rel="canonical" href="http://ganyuo.github.io/learn_note/qt_learn/"/>



<script type="text/javascript">
	/* 自动跳转到主要内容部分（主页除外） */
	const custom_fun = {
		load_to_main: function () {
			var pathname = window.location.pathname;
			var pre_pathname = sessionStorage.getItem("pre_pathname");
			var cur_st = $(document).scrollTop();
			if (pathname != "/" && cur_st < 10 && pathname != pre_pathname) {
				$('html, body').animate({
					scrollTop: $("#main").offset().top - 50
				}, 500);
			}
			sessionStorage.setItem("pre_pathname", pathname);
		},

		use_img_mirror: function(prefix) {
			var imgs = document.getElementsByTagName("img");
			for(var i = 0; i < imgs.length; i++) {
				img_src = imgs[i].src;
				ind = img_src.indexOf("images");
				if(ind >= 0) {
					imgs[i].src = prefix + img_src.substring(ind);
				}
			}
		}
	}

	$(function () {
		if (window.CONFIG.load_to_main) {
			custom_fun.load_to_main();
		}
		if (window.CONFIG.img_mirror.enable) {
			custom_fun.use_img_mirror(window.CONFIG.img_mirror.prefix);
		}
	})
</script>



  <title>Qt 学习笔记 | ganyuo</title>
  








<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="ganyuo" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-后宫">
          <a href="/friends/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-mars"></i> <br />
            
            后宫
          </a>
        </li>
      
        
        <li class="menu-item menu-item-留言板">
          <a href="/message/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-pencil"></i> <br />
            
            留言板
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-rocket"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>


	<a href="https://github.com/ganyuo" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub">
	<svg width="100" height="100" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0; z-index: 4;" aria-hidden="true">
		<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
		<path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
		<path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
	</svg>
</a>
<style>
.github-corner:hover .octo-arm{
	animation:octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave{
	0%,100%{transform:rotate(0)}
	20%,60%{transform:rotate(-25deg)}
	40%,80%{transform:rotate(10deg)}
}
@media (max-width:500px){
	.github-corner:hover .octo-arm{
		animation:none
	}
	.github-corner .octo-arm{
		animation:octocat-wave 560ms ease-in-out
	}
}
</style>



<div class="site-brand-wrapper" >
  <div class="site-meta ">
    

      
        <p class="site-subtitle"></p>
      
  </div>
</div>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-date">
			<div class="post-month">03月</div>
			<div class="post-day">11</div>
	</div>
  
  <div class="post-badge">
    
      <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
        <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
          <span itemprop="name">学习笔记</span>
        </a>
      </span>
    
  </div>
  

  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ganyuo.github.io/learn_note/qt_learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ganyuo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ganyuo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ganyuo">
    </span>

    
      <header class="post-header">

        
        
          <p class="post-title" itemprop="name headline">Qt 学习笔记</p>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-03-11T00:00:00+08:00">
                2023-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">•</span>
            <span class="page-pv">本文总阅读数 <i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  13.8k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="先说两句"><a class="markdownIt-Anchor" href="#先说两句"></a> 先说两句</h1>
<p>  最近偷懒了很久没有学习，对于自己的懒惰实在是看不下了，所以决定随便学点什么。但是最近没什么学习的方向，想起之前学过一点点Qt，但是没有学完，所有打算先把Qt学完，说不定以后能用上，随便记录一下学习笔记。我自己是一个自制力比较差的人，但是有点强迫症，如果了笔记没写完，会非常不舒服，所有以后以后把学的东西都记一下笔记，能一定程度上约束一下自己。突然想起之前写的shell脚本笔记还有<code>sed</code>命令还没学完，emmm…下次再补。</p>
<h1 id="qt简介"><a class="markdownIt-Anchor" href="#qt简介"></a> Qt简介</h1>
<p>  Qt是一个跨平台的C++开发库，主要用来开发图形用户界面程序。Qt还存在Python、Ruby、Perl等脚本语言的绑定，也就是说可以使用脚本语言开发基于 Qt 的程序。开源社区就是这样，好东西就会被派生扩展，到处使用，越来越壮大。</p>
<p>  Qt支持的操作系统有很多，例如通用操作系统Windows、Linux、Unix，智能手机系统Android、iOS、WinPhone，嵌入式系统QNX、VxWorks等等。</p>
<p>  上面是从<a href="http://c.biancheng.net/view/1792.html" target="_blank" rel="noopener">C语言中文网</a>上抄的Qt简介，附上<a href="https://www.qt.io" target="_blank" rel="noopener">Qt的官网</a>，感兴趣的小伙伴可以去看看。</p>
<p>  Qt包含很多C++的类，但是头文件代码里的注释基本没有，2333…，所以只能去看Qt官网上的文档：<a href="https://doc.qt.io/qt-5/classes.html" target="_blank" rel="noopener">https://doc.qt.io/qt-5/classes.html</a>，里面有所有类的说明。因为类太多了，所以后面关于类的成员函数就不解析了，小伙伴们有不清楚的地方可以去官网上查。</p>
<h1 id="环境搭建"><a class="markdownIt-Anchor" href="#环境搭建"></a> 环境搭建</h1>
<p>  我自己是在linuxmint系统下用VScode搭建的，具体参考这篇<a href="/learn_note/linux_qt_config/">博客</a>，其他系统下搭建环境的小伙伴也可以参考一下。</p>
<h1 id="pro文件配置"><a class="markdownIt-Anchor" href="#pro文件配置"></a> pro文件配置</h1>
<p>  pro文件只要用于配置Qt项目的编译，具体配置方式<s>抄</s>参考了一下大佬的这篇<a href="https://zhuanlan.zhihu.com/p/110782759" target="_blank" rel="noopener">文章</a></p>
<h2 id="常用配置项"><a class="markdownIt-Anchor" href="#常用配置项"></a> 常用配置项</h2>
<ol>
<li>
<p>注释 : 注释是从一行的<code>#</code>开始，到这一行的结束。</p>
</li>
<li>
<p><code>QT += </code> : 这个是添加QT项目需要的模块的，若项目中要排除某个模块，也可用<code>QT -= </code>配置项。</p>
</li>
<li>
<p><code>TEMPLATE = </code> : 这个配置项确定<code>qmake</code>为这个应用程序生成哪种<code>makefile</code> 。有下面五种形式可供选择：</p>
<ul>
<li><code>app</code> : 建立一个应用程序的makefile，这个是默认值，若模块项未指定，将默认使用此项；</li>
<li><code>lib</code> : 建立一个库的makefile；</li>
<li><code>vcapp</code> : 建立一个应用程序的VisualStudio项目文件；</li>
<li><code>vclib</code> : 建立一个库的VisualStudio项目文件；</li>
<li><code>subdirs</code> : 这是一个特殊的模板，可以创建一个可进入特定目录并为一个项目文件生成makefile，此makfile可以调用make；</li>
</ul>
</li>
<li>
<p><code>TARGET = </code>: 这个配置项用来指定最后生成的目标应用程序的名称。</p>
</li>
<li>
<p><code>CONFIG += </code> : 用来告诉qmake关于应用程序的配置信息，使用+=表示在现有的配置上添加，这样会更安全。比如，<code>CONFIG += qt warn_on release</code> 其具体的意义为：</p>
<ul>
<li><code>qt</code> : 告诉qmake此程序是使用qt来连编的。即qmake在连接、为编译添加所需包含路径时会考虑qt的库；</li>
<li><code>warn_on</code> : 告诉qmake要将编译器设置为输出警告信息形式；</li>
<li><code>release</code> : 告诉qmake应用程序必须被连编为一个可发布的应用程序。开发过程中，也可以使用<code>debug</code>；</li>
</ul>
</li>
<li>
<p><code>UIC_DIR += </code> : 用来指定<code>uic</code>命令，将<code>.ui</code>文件转化为<code>ui_*.h</code>文件存放的目录。</p>
</li>
<li>
<p><code>RCC_DIR += </code> : 用来指定<code>rcc</code>命令，将<code>.qrc</code>文件转换成<code>qrc_*.h</code>文件存放的目录。</p>
</li>
<li>
<p><code>MOC_DIR += </code> : 用来指定<code>moc</code>命令，将含有<code>Q_OBJECT</code>的头文件转换成标准<code>.h</code>文件存放的目录。</p>
</li>
<li>
<p><code>OBJECTS_DIR += </code> : 用来指定目标文件<code>obj</code>的存放目录。</p>
</li>
<li>
<p><code>DEPENDPATH += </code> : 用来指定工程的依赖路径。</p>
</li>
<li>
<p><code>INCLUDEPATH += </code> : 用来指定工程所需要的头文件。</p>
</li>
<li>
<p><code>CODECFORSRC += </code> : 用来指定源文件的编码格式。</p>
</li>
<li>
<p><code>FORMS += </code> : 用来指定工程中的<code>ui</code>文件。</p>
</li>
<li>
<p><code>HEADERS += </code> : 用来指定工程中所包含的头文件。</p>
</li>
<li>
<p><code>SOURCES += </code> : 用来指定工程中包含的源文件。</p>
</li>
<li>
<p><code>RESOURCES += </code> : 用来指定工程中所包含的资源文件。</p>
</li>
<li>
<p><code>LIBS += </code> : 用来指定引入的<code>lib</code>文件的路径，一般会在前面加下参数<code>-L</code>，根据不同的版本可以分为两种形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Release: LIBS +&#x3D; -L folder_Path # release版本引入的lib文件</span><br><span class="line">Debug: LIBS +&#x3D; -L folder_Path   # debug版本引入的lib文件</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>DEFINES += </code> : 用来定义编译选项。</p>
</li>
<li>
<p><code>DESTDIR += </code> : 用来指定目标的生成路径。</p>
</li>
<li>
<p>跨平台处理信息也要写在pro文件中。 其示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">win32</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unix</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="pro文件样例"><a class="markdownIt-Anchor" href="#pro文件样例"></a> pro文件样例</h2>
<p>下面是大佬给的一个pro文件样例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># 添加QT依赖的库</span><br><span class="line">QT +&#x3D; gui</span><br><span class="line">QT +&#x3D; core xml network multimedia serialport</span><br><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT +&#x3D; widgets</span><br><span class="line"></span><br><span class="line"># 添加c11配置支持</span><br><span class="line">CONFIG +&#x3D; c++11</span><br><span class="line"># 输出文件的名称</span><br><span class="line">TARGET &#x3D; YouAppName</span><br><span class="line"># 配置控制台输出</span><br><span class="line">CONFIG +&#x3D; console</span><br><span class="line"># 输出类型application</span><br><span class="line">TEMPLATE &#x3D; app</span><br><span class="line"></span><br><span class="line"># 源文件</span><br><span class="line">SOURCES +&#x3D; main.cpp \</span><br><span class="line">    appconfig.cpp \</span><br><span class="line">    opendoorthread.cpp \</span><br><span class="line">    TestProject&#x2F;testform.cpp \</span><br><span class="line">    TestProject&#x2F;common.pb.cpp \</span><br><span class="line">    TestProject&#x2F;goods_req.pb.cpp \</span><br><span class="line">    TestProject&#x2F;goods_resp.pb.cpp</span><br><span class="line"></span><br><span class="line"># 头文件</span><br><span class="line">HEADERS +&#x3D; \</span><br><span class="line">    appconfig.h \</span><br><span class="line">    opendoorthread.h \</span><br><span class="line">    TestProject&#x2F;testform.h \</span><br><span class="line">    TestProject&#x2F;common.pb.h \</span><br><span class="line">    TestProject&#x2F;goods_req.pb.h \</span><br><span class="line">    TestProject&#x2F;goods_resp.pb.h</span><br><span class="line"></span><br><span class="line"># 配置debug和release</span><br><span class="line">CONFIG +&#x3D;debug_and_release</span><br><span class="line">CONFIG(debug,debug|release)&#123;</span><br><span class="line">DESTDIR +&#x3D; $$PWD&#x2F;debug</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lThorModel</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lThorUtil</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lThorBLL</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lThorHardwareUtil</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lprotobufd</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lprotobuf-lited</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lopencv_core2410d</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lopencv_highgui2410d</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lopencv_imgproc2410d</span><br><span class="line">LIBS +&#x3D; -L$$PWD&#x2F;debug&#x2F; -lQtActionDetectd</span><br><span class="line">&#125;else&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 需要的头文件</span><br><span class="line">INCLUDEPATH +&#x3D; $$PWD&#x2F;AllDLL&#x2F;include</span><br><span class="line">INCLUDEPATH +&#x3D; $$PWD&#x2F;debug&#x2F;3rdparty&#x2F;opencv-2.4.10&#x2F;include \</span><br><span class="line">            $$PWD&#x2F;debug&#x2F;3rdparty&#x2F;opencv-2.4.10&#x2F;include&#x2F;opencv \</span><br><span class="line">            $$PWD&#x2F;debug&#x2F;3rdparty&#x2F;opencv-2.4.10&#x2F;include&#x2F;opencv2</span><br><span class="line"># ui</span><br><span class="line">FORMS +&#x3D; \</span><br><span class="line">    TestProject&#x2F;testform.ui</span><br></pre></td></tr></table></figure>
<h1 id="gui"><a class="markdownIt-Anchor" href="#gui"></a> GUI</h1>
<p>  Qt的很多GUI控件都是继承自QWidget，所以使用Qt的GUI一般都需要加上<code>widgets</code>和<code>gui</code>这两个库，pro项目文件样例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 添加widgets和gui库</span><br><span class="line">QT +&#x3D; widgets gui</span><br><span class="line"></span><br><span class="line"># 把main.cpp加到项目的代码列表里</span><br><span class="line">SOURCES +&#x3D; \</span><br><span class="line">    main.cpp</span><br></pre></td></tr></table></figure>
<h2 id="qwidget"><a class="markdownIt-Anchor" href="#qwidget"></a> QWidget</h2>
<p>  QWidget是Qt的窗口类，下面是一段样例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt; /* 应用程序抽象类 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;  /* 窗口类 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>; <span class="comment">/* 创建一个Qt应用 */</span></span><br><span class="line"></span><br><span class="line">    QWidget widget; <span class="comment">/* 构造一个窗口 */</span></span><br><span class="line">    widget.setWindowTitle(<span class="string">"Hello World"</span>); <span class="comment">/* 设置窗口标题 */</span></span><br><span class="line">    widget.show(); <span class="comment">/* 显示窗口 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.exec(); <span class="comment">/* exec():进入消息循环 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  上面的代码中，创建了一个标题是<code>Hello World</code>的窗口。执行<code>app.exec();</code>后，会进入一个处理消息的死循环，<code>app</code>会捕获系统消息，并传递给<code>widget</code>窗口。这就是鼠标点击后能拖动窗口的原因，<code>app</code>将鼠标的点击、移动等消息传递给了<code>widget</code>，<code>widget</code>作出了对应的响应，窗口移动了位置。</p>
<h2 id="控件"><a class="markdownIt-Anchor" href="#控件"></a> 控件</h2>
<p>  Qt里有很多控件，大部分都是继承自<code>Qwidget</code>，所以控件也可以看作是一个窗口，这里列举一些常用的控件(抄大佬的这篇<a href="https://zhuanlan.zhihu.com/p/612560027" target="_blank" rel="noopener">博客</a>)：</p>
<table>
<thead>
<tr>
<th>控件</th>
<th>类名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>标签</td>
<td>QLabel</td>
<td>显示一个文本或图像。</td>
</tr>
<tr>
<td>按钮</td>
<td>QPushButton</td>
<td>用户可以点击的一个按钮，用来触发某个操作。</td>
</tr>
<tr>
<td>输入框</td>
<td>QLineEdit</td>
<td>用户可以在其中输入文本的一个输入框。</td>
</tr>
<tr>
<td>复选框</td>
<td>QCheckBox</td>
<td>用户可以勾选或取消的一个复选框。</td>
</tr>
<tr>
<td>单选按钮</td>
<td>QRadioButton</td>
<td>用户可以选择其中一个选项的一组单选按钮。</td>
</tr>
<tr>
<td>数字微调框</td>
<td>QSpinBox</td>
<td>用于选择一个数值的微调框。</td>
</tr>
<tr>
<td>滑动条</td>
<td>QSlider</td>
<td>用户可以通过滑动来选择数值的一个滑动条。</td>
</tr>
<tr>
<td>列表框</td>
<td>QListWidget</td>
<td>用于显示一组列表项的一个列表框。</td>
</tr>
<tr>
<td>组合框</td>
<td>QComboBox</td>
<td>类似于下拉菜单的一个组合框，用户可以选择其中一个选项。</td>
</tr>
<tr>
<td>多行文本框</td>
<td>QTextEdit</td>
<td>用户可以在其中编辑多行文本的一个文本编辑框。</td>
</tr>
<tr>
<td>日期和时间编辑框</td>
<td>QDateTimeEdit</td>
<td>用于选择日期和时间的一个日期和时间编辑框。</td>
</tr>
</tbody>
</table>
<p>  由于控件种类太多了，这里只介绍一下按钮<code>QPushButton</code>和输入框<code>QLineEdit</code>这两种控件，其他控件的很多性质和接口都比较相似，小伙伴们可以自己尝试，<s>我就偷懒不写了</s>。</p>
<h3 id="按钮-qpushbutton"><a class="markdownIt-Anchor" href="#按钮-qpushbutton"></a> 按钮-QPushButton</h3>
<p>  下面是一个在窗口中添加一个按钮的样例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt; /* 应用程序抽象类 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;  /* 窗口类 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt; /* 按钮类 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget widget; <span class="comment">/* 构造一个窗口 */</span></span><br><span class="line">    widget.show(); <span class="comment">/* 显示窗口 */</span></span><br><span class="line"></span><br><span class="line">    QPushButton button; <span class="comment">/* 创建一个按钮对象 */</span></span><br><span class="line">    button.setText(<span class="string">"Button"</span>); <span class="comment">/* 设置按钮显示的文本 */</span></span><br><span class="line">    button.setParent(&amp;widget); <span class="comment">/* 设置按钮的父窗口 */</span></span><br><span class="line">    button.show(); <span class="comment">/* 显示按钮 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.exec(); <span class="comment">/* exec():进入消息循环 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  上面的代码会创建一个窗口，窗口中包含一个按钮。在Qt中，<code>QPushButton</code>是<code>QWidget</code>的子类，所以按钮也可以看作是一个窗口。</p>
<p>  Qt里的窗口可以存在父子关系，上面的代码中，<code>button.setParent(&amp;widget);</code>的作用是将<code>button</code>按钮的父窗口设置成<code>widget</code>，设置后<code>button</code>按钮才会显示在<code>widget</code>窗口里面；如果不设置，<code>button</code>按钮会显示成一个独立的窗口，与<code>widget</code>窗口同级。</p>
<p>  一个窗口在执行<code>show()</code>成员函数时，会将已经添加的子窗口也一起显示，如果是子窗口是在父窗口执行<code>show()</code>之后添加的，则子窗口不会显示，子窗口也需要执行<code>show()</code>才能显示出来。比如，去掉上面代码中的<code>button.show()</code>之后，虽然之后将<code>button</code>按钮添加到了父窗口<code>widget</code>里，但是<code>widget</code>窗口里的<code>button</code>按钮不显示。如果在<code>widget</code>窗口执行<code>show()</code>之前，将<code>button</code>按钮添加到了父窗口<code>widget</code>里，也就是在<code>widget.show()</code>之前执行<code>button.setParent(&amp;widget)</code>，则即使<code>button</code>按钮不执行<code>show()</code>，也会在父窗口<code>widget</code>执行<code>show()</code>的时候一起显示出来。</p>
<h3 id="输入框-qlineedit"><a class="markdownIt-Anchor" href="#输入框-qlineedit"></a> 输入框-QLineEdit</h3>
<p>  下面是一个输入框的样例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt; /* 应用程序抽象类 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;      /* 窗口类 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLineEdit&gt;    /* 输入框 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCompleter&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QWidget widget; <span class="comment">/* 构造一个窗口 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加两个输入框 */</span></span><br><span class="line">    QLineEdit name_input, password_input;</span><br><span class="line">    <span class="function">QVBoxLayout <span class="title">layout</span><span class="params">(&amp;widget)</span></span>;</span><br><span class="line">    layout.addWidget(&amp;name_input);</span><br><span class="line">    layout.addWidget(&amp;password_input);</span><br><span class="line"></span><br><span class="line">    <span class="function">QCompleter <span class="title">completer</span><span class="params">(QStringList() &lt;&lt; <span class="string">"abc"</span> &lt;&lt; <span class="string">"aaa"</span> &lt;&lt; <span class="string">"123"</span>)</span></span>;</span><br><span class="line">    completer.setFilterMode(Qt::MatchContains);</span><br><span class="line">    name_input.setCompleter(&amp;completer); <span class="comment">/* 设置输入匹配提示 */</span></span><br><span class="line">    name_input.setPlaceholderText(<span class="string">"请用户名"</span>); <span class="comment">/* 设置输入提示 */</span></span><br><span class="line"></span><br><span class="line">    password_input.setEchoMode(QLineEdit::Password); <span class="comment">/* 设置回显模式为密码模式 */</span></span><br><span class="line">    password_input.setPlaceholderText(<span class="string">"请输入密码"</span>); <span class="comment">/* 设置输入提示 */</span></span><br><span class="line"></span><br><span class="line">    widget.show(); <span class="comment">/* 显示窗口 */</span></span><br><span class="line">    <span class="keyword">return</span> app.exec(); <span class="comment">/* exec():进入消息循环 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  上面的代码向窗口中添加了两个输入框，一个用来输入用户名，一个用来输入密码。用户名输入框设置了一个<code>completer</code>，可以将输入的字符串与<code>completer</code>的字符串列表进行匹配，显示匹配成功的字符串。密码输入框设置了设置回显模式为密码模式，可以将输入的字符显示为<code>●</code>。</p>
<h2 id="坐标体系"><a class="markdownIt-Anchor" href="#坐标体系"></a> 坐标体系</h2>
<p>  Qt里的<code>Qwidget</code>可以使用<code>setGeometry()</code>来设置控件的位置坐标，位置坐标是相对与父窗口的左上角计算的，下面是一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QWidget widget;</span><br><span class="line">QPushButton button;</span><br><span class="line">button.setText(<span class="string">"Button"</span>);</span><br><span class="line">button.setParent(&amp;widget);</span><br><span class="line"><span class="comment">/* 设置button相对父窗口的坐标ax,ay，以及button的宽度aw和高度ah */</span></span><br><span class="line">button.setGeometry(<span class="number">30</span>, <span class="number">30</span>, <span class="number">200</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>  上面的例子中，<code>setGeometry()</code>有4个参数，前两个参数是<code>button</code>相对父窗口的坐标ax，ay，后面两个是<code>button</code>的宽度和高度aw，ah。</p>
<h2 id="layout"><a class="markdownIt-Anchor" href="#layout"></a> layout</h2>
<p>  当一个窗口里控件很多时，使用<code>setGeometry()</code>来设置很麻烦，而且无法随着窗口的大小变化而调整。使用layout(布局)就可以很方便的解决这个问题，他们负责一组控件的几何管理。上面<a href="#%E8%BE%93%E5%85%A5%E6%A1%86-QLineEdit">输入框-QLineEdit</a>里的样例代码，使用的<code>QVBoxLayout</code>就是一种layout，可以将控件在垂直方向上排列，使得<code>name_input</code>输入框在<code>password_input</code>输入框上面，如果不使用layout，则两个输入框会重叠在一起。(以下内容大部分抄的大佬的这篇<a href="https://blog.csdn.net/leacock1991/article/details/118947828" target="_blank" rel="noopener">博客</a>)</p>
<h3 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h3>
<p>  Qt布局系统提供了一种简单而强大的方法，可以在控件内自动排列子控件，以确保它们充分利用可用空间。Qt包含一组布局管理类，用于描述控件在应用程序用户界面中的布局方式。当控件的可用空间发生变化时，这些layout会自动定位和调整控件的大小，确保它们的排列一致并且用户界面作为一个整体仍然可用。</p>
<p>  所有<code>QWidget</code>子类都可以使用layout来管理它们的子类。<code>QWidget::setLayout()</code>函数可以为一个控件设置layout。 当以这种方式在窗口上设置layout时，它负责以下任务：</p>
<ul>
<li>布置子控件。</li>
<li>最高层窗口可感知的默认大小。</li>
<li>最高层窗口可感知的最小大小。</li>
<li>调整大小的处理。</li>
<li>当内容改变的时候自动更新：
<ul>
<li>字体大小、文本或者子控件的其它内容。</li>
<li>隐藏或者显示子控件。</li>
<li>移除一些子控件。</li>
</ul>
</li>
</ul>
<h3 id="常用layout"><a class="markdownIt-Anchor" href="#常用layout"></a> 常用layout</h3>
<p>  为控件提供良好布局的最简单方法是使用Qt内置的布局管理器：<code>QHBoxLayout</code>、<code>QVBoxLayout</code>、<code>QGridLayout</code>和<code>QFormLayout</code>。这些类从<code>QLayout</code>继承，而<code>QLayout</code>又从<code>QObject</code>（而不是<code>QWidget</code>）派生。他们负责一组控件的几何管理。要创建更复杂的布局，可以将布局管理器相互嵌套。</p>
<ul>
<li>
<p><code>QHBoxLayout</code>：从左到右在水平行中布置控件。</p>
<p><img src="/images/learn_note/qt_learn/fig_1.png" alt="" /></p>
</li>
<li>
<p><code>QVBoxLayout</code>：在垂直列中从上到下布置控件。</p>
<p><img src="/images/learn_note/qt_learn/fig_2.png" alt="" /></p>
</li>
<li>
<p><code>QGridLayout</code>：在二维网格中布置控件，控件可以占用多个单元格。</p>
<p><img src="/images/learn_note/qt_learn/fig_3.png" alt="" /></p>
</li>
<li>
<p><code>QFormLayout</code>：把控件按照标签-输入框的形式排列在两列。</p>
<p><img src="/images/learn_note/qt_learn/fig_4.png" alt="" /></p>
</li>
</ul>
<h3 id="为layout添加控件"><a class="markdownIt-Anchor" href="#为layout添加控件"></a> 为layout添加控件</h3>
<p>  将控件添加到一个layout时，布局过程如下：</p>
<ol>
<li>所有控件最初将根据它们的<code>QWidget::sizePolicy()</code>和<code>QWidget::sizeHint()</code>分配一定数量的空间。</li>
<li>如果任何控件设置了拉伸系数，并且其值大于零，那么它们将按其拉伸因子的比例分配空间（如下<a href="#%E4%BC%B8%E5%B1%95%E5%9B%A0%E7%B4%A0">伸展因素</a>所述）。</li>
<li>如果任何控件的拉伸系数设置为零，它们只会在没有其他控件需要空间的情况下获得更多空间。其中，空间首先分配给具有扩展大小策略的控件。</li>
<li>任何控件被分配的空间的大小如果小于它们的最小大小（如果未指定最小尺寸，则为最小尺寸提示），它们就会被按它们所需要的最小大小分配空间。（如果控件的伸展因素是它们的决定因素，它们不必有最小大小或者最小大小的提示。）</li>
<li>任何控件被分配的空间的大小如果大于它们的最大大小，它们就会被按它们所需要的最大大小分配空间。（如果控件的伸展因素是它们的决定因素，它们不必有最大大小。）</li>
</ol>
<h3 id="伸展因素"><a class="markdownIt-Anchor" href="#伸展因素"></a> 伸展因素</h3>
<p>  控件通常是在没有伸展因素设置的情况下被生成的。当它们被布置到一个layout中时，控件会被根据它们的<code>QWidget::sizePolicy()</code>或者它们的最小大小的提示中大的那一个分配给整个空间的一部分。伸展因素是用来根据控件互相的比例来改变它们所被分配的空间。</p>
<p>  如果使用一个<code>QHBoxLayout</code>来布置没有伸展参数设置的三个控件，则我们就会得到像下面这样的布局：</p>
<p><img src="/images/learn_note/qt_learn/fig_5.png" alt="" /></p>
<p>  如果我们给每个控件设置一个伸展因素，它们就会被按比例布置（但是不能小于最小大小的提示），以下是按1:3:2设置的：</p>
<p><img src="/images/learn_note/qt_learn/fig_6.png" alt="" /></p>
<h3 id="简单的demo"><a class="markdownIt-Anchor" href="#简单的demo"></a> 简单的demo</h3>
<p>  布局中常用的方法有<code>addWidget()</code>和<code>addLayout()</code>，<code>addWidget()</code>方法用于向layout中加入需要布局的控件，<code>addLayout()</code>方法用于向layout中加入子布局。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addWidget</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    QWidget *widget, <span class="comment">// 需要插入的控件对象</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> fromRow,     <span class="comment">// 插入的行</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> fromColumn,  <span class="comment">// 插入的列</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> rowSpan,     <span class="comment">// 占用的行</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> columnSpan,  <span class="comment">// 占用的列数</span></span></span></span><br><span class="line"><span class="function"><span class="params">    Qt::Alignment alignment = Qt::Alignment <span class="comment">// 各个控件的对齐方式</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    QLayout *layout, <span class="comment">// 需要插入的子布局对象</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> row,         <span class="comment">// 插入的起始行</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> column,      <span class="comment">// 插入的起始列</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> rowSpan,     <span class="comment">// 占用的行数</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> columnSpan,  <span class="comment">// 占用的列数</span></span></span></span><br><span class="line"><span class="function"><span class="params">    Qt::Alignment alignment = Qt::Alignment <span class="comment">// 指定的对齐方式</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>  下面是一个样例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QVBoxLayout&gt; /* 垂直布局 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QHBoxLayout&gt; /* 水平布局 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QGridLayout&gt; /* 格子布局 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QWidget widget;</span><br><span class="line"></span><br><span class="line">    QGridLayout layout;            <span class="comment">// 创建格子布局</span></span><br><span class="line">    layout.setRowStretch(<span class="number">0</span>, <span class="number">1</span>);    <span class="comment">// 设置第0行的拉伸系数</span></span><br><span class="line">    layout.setColumnStretch(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 设置第0列的拉伸系数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向layout中添加控件 */</span></span><br><span class="line">    layout.addWidget(<span class="keyword">new</span> QLabel(<span class="string">"用户名："</span>), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    layout.addWidget(<span class="keyword">new</span> QLineEdit(), <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    layout.addWidget(<span class="keyword">new</span> QLabel(<span class="string">"密码："</span>), <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    layout.addWidget(<span class="keyword">new</span> QLineEdit(), <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向layout中添加子布局 */</span></span><br><span class="line">    QHBoxLayout hbox;</span><br><span class="line">    hbox.addStretch(<span class="number">1</span>);  <span class="comment">// 添加伸缩量</span></span><br><span class="line">    hbox.addWidget(<span class="keyword">new</span> QPushButton(<span class="string">"登录"</span>));</span><br><span class="line">    layout.addLayout(&amp;hbox, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    layout.setRowStretch(<span class="number">4</span>, <span class="number">1</span>);    <span class="comment">// 设置最后一行的拉伸系数</span></span><br><span class="line">    layout.setColumnStretch(<span class="number">3</span>, <span class="number">1</span>); <span class="comment">// 设置最后一列的拉伸系数</span></span><br><span class="line"></span><br><span class="line">    widget.setLayout(&amp;layout); <span class="comment">// 给窗口设置layout</span></span><br><span class="line">    widget.show();</span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主窗口"><a class="markdownIt-Anchor" href="#主窗口"></a> 主窗口</h2>
<p>  抄了大佬的这篇<a href="https://www.cnblogs.com/happinesspills/p/16542209.html" target="_blank" rel="noopener">博客</a>。</p>
<p>  主窗口<code>QMainWindow</code>是一个为用户提供主窗口程序的类，包含一个菜单栏（menu bar）、多个工具栏(tool bars)、多个浮动窗口(dock widgets)、一个状态栏(status bar)及一个中心区域(central widget)，主窗口是许多应用程序的基础，如文本编辑器，图片编辑器等。</p>
<p>下面是一个使用<code>QMainWindow</code>的样例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMenuBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMenu&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QAction&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QToolBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QStatusBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDockWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QGridLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSystemTrayIcon&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QMainWindow main_win;</span><br><span class="line">    main_win.resize(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 菜单栏 */</span></span><br><span class="line">    QMenuBar *meun_bar = main_win.menuBar(); <span class="comment">/* 获取主窗口的菜单栏 */</span></span><br><span class="line">    QMenu *file_menu = meun_bar-&gt;addMenu(<span class="string">"&amp;file"</span>); <span class="comment">/* 在菜单栏里添加一个file菜单 */</span></span><br><span class="line">    QMenu *edit_menu = meun_bar-&gt;addMenu(<span class="string">"&amp;edit"</span>); <span class="comment">/* 再添加一个edit菜单 */</span></span><br><span class="line">    QAction *open_action = file_menu-&gt;addAction(<span class="string">"&amp;open"</span>); <span class="comment">/* 向file菜单里添加Action */</span></span><br><span class="line">    QAction *save_action = file_menu-&gt;addAction(<span class="string">"&amp;save"</span>);</span><br><span class="line">    file_menu-&gt;addSeparator();  <span class="comment">/* 向file菜单里添加分割线 */</span></span><br><span class="line">    QAction *exit_action = file_menu-&gt;addAction(<span class="string">"&amp;exit"</span>);</span><br><span class="line">    <span class="comment">/* 将exit Action的触发信号，连接到主窗口的关闭槽函数，实现点击exit后关闭主窗口 */</span></span><br><span class="line">    QObject::connect(exit_action, SIGNAL(triggered(<span class="keyword">bool</span>)), &amp;main_win, SLOT(close()));</span><br><span class="line">    exit_action-&gt;setToolTip(<span class="string">"close window"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 工具栏 */</span></span><br><span class="line">    QToolBar *tool_bar = main_win.addToolBar(<span class="string">"tool_bar"</span>); <span class="comment">/* 向主窗口添加工具栏 */</span></span><br><span class="line">    tool_bar-&gt;addAction(open_action); <span class="comment">/* 向工具栏中添加Action */</span></span><br><span class="line">    tool_bar-&gt;addAction(save_action);</span><br><span class="line">    tool_bar-&gt;addAction(exit_action);</span><br><span class="line">    tool_bar-&gt;setAllowedAreas(Qt::AllToolBarAreas); <span class="comment">/* 设置可停靠区域 */</span></span><br><span class="line">    tool_bar-&gt;setFloatable(<span class="literal">true</span>); <span class="comment">/* 设置是否可以浮动 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 状态栏 */</span></span><br><span class="line">    QStatusBar *status_bar = main_win.statusBar();  <span class="comment">/* 获取主窗口的状态栏 */</span></span><br><span class="line">    QLabel *status_label = <span class="keyword">new</span> QLabel(<span class="string">"main window running..."</span>);</span><br><span class="line">    status_bar-&gt;addWidget(status_label);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 浮动窗口 */</span></span><br><span class="line">    <span class="function">QDockWidget <span class="title">dock_widget</span><span class="params">(<span class="string">"浮动窗口"</span>, &amp;main_win)</span></span>; <span class="comment">/* 创建浮动窗口 */</span></span><br><span class="line">    dock_widget.setMinimumWidth(<span class="number">100</span>); <span class="comment">/* 设置最小宽度 */</span></span><br><span class="line">    <span class="comment">/* 将浮动窗口放在主窗口的左边 */</span></span><br><span class="line">    main_win.addDockWidget(Qt::LeftDockWidgetArea, &amp;dock_widget);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 中心区域，别的控件占用了之后，剩下的区域都是CentralWidget */</span></span><br><span class="line">    QWidget central_widget;</span><br><span class="line">	QGridLayout central_layout;</span><br><span class="line">	central_layout.setRowStretch(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	central_layout.setColumnStretch(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	central_layout.addWidget(<span class="keyword">new</span> QLabel(<span class="string">"用户名："</span>), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	central_layout.addWidget(<span class="keyword">new</span> QLineEdit(), <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	central_layout.addWidget(<span class="keyword">new</span> QLabel(<span class="string">"密码："</span>), <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">	central_layout.addWidget(<span class="keyword">new</span> QLineEdit(), <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	central_layout.setRowStretch(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">	central_layout.setColumnStretch(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">	central_widget.setLayout(&amp;central_layout);</span><br><span class="line">    main_win.setCentralWidget(&amp;central_widget); <span class="comment">/* 设置主窗口的中心区域 */</span></span><br><span class="line"></span><br><span class="line">    main_win.show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 系统托盘图标 */</span></span><br><span class="line">    QSystemTrayIcon tray_icon;</span><br><span class="line">    tray_icon.setIcon(QIcon(<span class="string">"image/滑稽.png"</span>)); <span class="comment">/* 设置图标图片 */</span></span><br><span class="line">    tray_icon.setContextMenu(file_menu);  <span class="comment">/* 设置菜单 */</span></span><br><span class="line">    tray_icon.show();</span><br><span class="line"></span><br><span class="line">    app.exec();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：</p>
<p><img src="/images/learn_note/qt_learn/fig_8.png" alt="" /></p>
<h3 id="菜单栏"><a class="markdownIt-Anchor" href="#菜单栏"></a> 菜单栏</h3>
<p>  一个主窗口最多只有一个菜单栏。通过<code>QMainWindow</code>类的<code>menuBar()</code>函数可以获取主窗口菜单栏指针，如果当前窗口没有菜单栏，该函数会自动创建一个。</p>
<p>  Qt 并没有专门的菜单项类，只是使用一个<code>QAction</code>类，抽象出公共的动作。当我们把<code>QAction</code>对象添加到菜单，就显示成一个菜单项，添加到工具栏，就显示成一个工具按钮。用户可以通过点击菜单项、点击工具栏按钮、点击快捷键来激活这个动作。</p>
<h3 id="工具栏"><a class="markdownIt-Anchor" href="#工具栏"></a> 工具栏</h3>
<p>  主窗口可以有多个工具栏，通常采用一个菜单对应一个工具栏的的方式，也可根据需要进行工具栏的划分。</p>
<p>  调用<code>QMainWindowd</code>对象的成员函数<code>addToolBar()</code>会创建一个新的工具栏，并且返回该工具栏的指针。通过<code>QToolBar</code>类的<code>addAction()</code>函数可以添加插入属于工具栏的项，工具栏上添加项也是用<code>QAction</code>。</p>
<p>  工具栏是一个可移动的窗口，它的可停靠区域由<code>QToolBar</code>的<code>allowAreas</code>决定，包括以下可用值：</p>
<ul>
<li><code>Qt::LeftToolBarArea</code>：停靠在左侧</li>
<li><code>Qt::RightToolBarArea</code>：停靠在右侧</li>
<li><code>Qt::TopToolBarArea</code>：停靠在顶部</li>
<li><code>Qt::BottomToolBarArea</code>：停靠在底部</li>
<li><code>Qt::AllToolBarAreas</code>：以上四个位置都可停靠</li>
</ul>
<p>使用<code>setAllowedAreas()</code>函数指定停靠区域，使用<code>setFloatable()</code>函数可以设置工具栏是否可以浮动。</p>
<h3 id="状态栏"><a class="markdownIt-Anchor" href="#状态栏"></a> 状态栏</h3>
<p>  一个<code>QMainWindow</code>的程序最多只有一个状态栏。<code>QMainWindow</code>中可以有多个的部件都使用add…名字的函数，而只有一个的部件，就直接使用获取部件的函数，如menuBar。同理状态栏也提供了一个获取状态栏的函数<code>statusBar()</code>，没有就自动创建一个并返回状态栏的指针，状态栏可以使用<code>addWidget()</code>接口来添加内容。</p>
<h3 id="浮动窗口"><a class="markdownIt-Anchor" href="#浮动窗口"></a> 浮动窗口</h3>
<p>  即<code>QDockWidget</code>，也称为铆接部件，可以有多个。主窗口可以使用<code>addDockWidget()</code>成员函数添加浮动窗口。</p>
<h3 id="中心区域"><a class="markdownIt-Anchor" href="#中心区域"></a> 中心区域</h3>
<p>  除了以上几个部件占用的区域外，剩下的区域都是中心区域，中心区域只有一个，使用<code>setCentralWidget()</code>函数设置中心区域。</p>
<h3 id="系统托盘图标"><a class="markdownIt-Anchor" href="#系统托盘图标"></a> 系统托盘图标</h3>
<p>  系统托盘图标并不是<code>QMainWindow</code>里的内容，Qt 中使用<code>QSystemTrayIcon</code>类来创建系统托盘图标，可以使用<code>QSystemTrayIcon</code>的<code>setIcon()</code>成员函数设置图标，使用<code>setContextMenu()</code>设置鼠标右键菜单。</p>
<h2 id="对话框"><a class="markdownIt-Anchor" href="#对话框"></a> 对话框</h2>
<p>  抄了大佬的这篇<a href="https://blog.csdn.net/m0_56069910/article/details/141726782" target="_blank" rel="noopener">博客</a>。</p>
<p>  对话框是GUI程序中不可或缺的组成部分。⼀些不适合在主窗⼝实现的功能组件可以设置在对话框中。对话框通常是⼀个顶层窗口，出现在程序最上层，⽤于实现短期任务或者简洁的用户交互。对话框主要可以分为模态对话框和⾮模态对话框。</p>
<p>  Qt中的对话框类为<code>QDialog</code>，是<code>QWidget</code>的子类，<code>QWidget</code>的各种属性方法，在<code>QDialog</code>也同样适用。</p>
<h3 id="模态对话框"><a class="markdownIt-Anchor" href="#模态对话框"></a> 模态对话框</h3>
<p>  模态对话框的特点是：显示后无法与父窗口进行交互，是⼀种阻塞式的对话框。在 Qt 中使用<code>QDialog::exec()</code>函数调用。模态对话框适用于必须依赖用户选择的场合，⽐如消息显示，文件选择，打印设置等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QDialog model_dialog;</span><br><span class="line">model_dialog.setWindowTitle(<span class="string">"模态对话框"</span>);</span><br><span class="line">model_dialog.exec(); <span class="comment">/* 阻塞显示对话框 */</span></span><br></pre></td></tr></table></figure>
<h3 id="非模态对话框"><a class="markdownIt-Anchor" href="#非模态对话框"></a> 非模态对话框</h3>
<p>  非模态对话框的特点是：显示后独立存在，可以同时与父窗口进行交互，是⼀种非阻塞式对话框，使用<code>QDialog::show()</code>函数调用。⾮模态对话框⼀般在堆上创建，这是因为如果创建在栈上时，当函数运行结束后，弹出的⾮模态对话框会被释放。⾮模态对话框适用于特殊功能设置的场合，⽐如查找操作，属性设置等。</p>
<p>  Qt 可以通过设置<code>Qt:WA_DeleteOnClose</code>属性，实现在对话框在关闭的时候被<code>delete</code>掉，避免内存泄漏。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QDialog *modaless_dialog = <span class="keyword">new</span> QDialog();</span><br><span class="line">modaless_dialog-&gt;setWindowTitle(<span class="string">"非模态对话框"</span>);</span><br><span class="line"><span class="comment">/* 关闭窗口的时候触发delete操作，防止内存泄漏 */</span></span><br><span class="line">modaless_dialog-&gt;setAttribute(Qt::WA_DeleteOnClose);</span><br><span class="line">modaless_dialog-&gt;show(); <span class="comment">/* 非阻塞显示对话框 */</span></span><br></pre></td></tr></table></figure>
<h3 id="qt常用的对话框"><a class="markdownIt-Anchor" href="#qt常用的对话框"></a> Qt常用的对话框</h3>
<p>  Qt 提供了多种可复复用的对话框类型，即Qt标准对话框。Qt标准对话框全部继承于<code>QDialog</code>类。常用标准对话框如下：</p>
<ul>
<li><code>QMessageBox</code>：消息对话框</li>
<li><code>QFileDialog</code>：文件对话框</li>
<li><code>QColorDialog</code>：颜色对话框</li>
<li><code>QFontDialog</code>：字体对话框</li>
<li><code>QInputDialog</code>：输入对话框</li>
</ul>
<h4 id="消息对话框"><a class="markdownIt-Anchor" href="#消息对话框"></a> 消息对话框</h4>
<p>  消息对话框主要用于为用户提示重要消息，强制用户进行选择操作。<code>QMessageBox</code>提供了多种静态方法来快速显示不同类型的消息框：</p>
<ul>
<li>information：显示一个信息消息框  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox::information(<span class="literal">nullptr</span>, <span class="string">"信息消息框"</span>, <span class="string">"假装这是一条信息消息"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>warning：显示一个警告消息框  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox::warning(<span class="literal">nullptr</span>, <span class="string">"警告消息框"</span>, <span class="string">"假装这是一条警告消息"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>critical：显示一个严重错误消息框  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox::critical(<span class="literal">nullptr</span>, <span class="string">"错误消息框"</span>, <span class="string">"假装这是一条错误消息"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>question：显示一个问题消息框，允许用户做出选择  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = QMessageBox::question(<span class="literal">nullptr</span>, <span class="string">"问题消息框"</span>, <span class="string">"假装这是一个问题"</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == QMessageBox::Yes) &#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"return yes"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"return no"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="文件对话框"><a class="markdownIt-Anchor" href="#文件对话框"></a> 文件对话框</h4>
<p>  文件对话框<code>QFiledialog</code>是一个模态对话框，主要用于让用户可以浏览文件系统、并选择文件或目录。</p>
<ul>
<li>打开一个文件，返回文件的绝对路径  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString file_path = QFileDialog::getOpenFileName();</span><br></pre></td></tr></table></figure>
</li>
<li>打开多个文件，返回文件的绝对路径列表  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QStringList file_path_list = QFileDialog::getOpenFileNames();</span><br></pre></td></tr></table></figure>
</li>
<li>打开目录，返回目录的绝对路径  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString dir_path = QFileDialog::getExistingDirectory();</span><br></pre></td></tr></table></figure>
</li>
<li>保存文件，返回文件的绝对路径  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString file_path = QFileDialog::getSaveFileName();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="颜色对话框"><a class="markdownIt-Anchor" href="#颜色对话框"></a> 颜色对话框</h4>
<p>  颜色对话框<code>QColorDialog</code>是一个模态对话框，用于让用户选择颜色。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QColor color = QColorDialog::getColor();</span><br></pre></td></tr></table></figure>
<h4 id="字体对话框"><a class="markdownIt-Anchor" href="#字体对话框"></a> 字体对话框</h4>
<p>  字体对话框<code>QFontDialog</code>也是一个模态对话框，用于让用户选择字体的样式、大小、粗细等属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">QFont font = QFontDialog::getFont(&amp;flag);</span><br></pre></td></tr></table></figure>
<h4 id="输入对话框"><a class="markdownIt-Anchor" href="#输入对话框"></a> 输入对话框</h4>
<p>  输入对话框<code>QInputDialog</code>也是一个模态对话框，主要用于让用户输入文本、数字或选择列表中的一个选项。</p>
<ul>
<li>浮点数输入对话框  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> ret = QInputDialog::getDouble(<span class="literal">nullptr</span>, <span class="string">"输入对话框"</span>, <span class="string">"输入浮点数"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>整数输入对话框  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = QInputDialog::getInt(<span class="literal">nullptr</span>, <span class="string">"输入对话框"</span>, <span class="string">"输入整数"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>选项列表输入对话框  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString ret = QInputDialog::getItem(<span class="literal">nullptr</span>, <span class="string">"输入对话框"</span>, <span class="string">"选择选项"</span>, </span><br><span class="line">                                    &#123;<span class="string">"选项_1"</span>, <span class="string">"选项_2"</span>, <span class="string">"选项_3"</span>&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="画板"><a class="markdownIt-Anchor" href="#画板"></a> 画板</h2>
<p>  抄了大佬的这篇<a href="https://zhuanlan.zhihu.com/p/638570663" target="_blank" rel="noopener">博客</a>。</p>
<p>  <code>QPainter</code>是 Qt 中用于进行绘图操作的类。它提供了各种绘制函数，可以在不同的绘图设备上进行绘制，如窗口、图像、打印机等。</p>
<p>以下是<code>QPainter</code>类的一些常用属性和方法：</p>
<ul>
<li><code>begin(QPaintDevice *device)</code>: 在给定的绘图设备上开始绘制操作。</li>
<li><code>end()</code>: 结束绘制操作。</li>
<li><code>drawText(const QRectF &amp;rectangle, const QString &amp;text)</code>: 绘制指定矩形区域内的文本。</li>
<li><code>drawImage(const QRectF &amp;target, const QImage &amp;image, const QRectF &amp;source)</code>: 在目标矩形区域内绘制源图像的一部分。</li>
<li><code>setPen(const QPen &amp;pen)</code>: 设置绘制的画笔样式。</li>
<li><code>setBrush(const QBrush &amp;brush)</code>: 设置绘制的画刷样式。</li>
<li><code>setFont(const QFont &amp;font)</code>: 设置绘制的字体样式。</li>
<li><code>translate(const QPointF &amp;offset)</code>: 将绘图坐标原点平移指定的偏移量。</li>
<li><code>scale(qreal sx, qreal sy)</code>: 沿着x轴和y轴方向对绘图进行缩放。</li>
<li><code>rotate(qreal angle)</code>: 以原点为中心，按照给定的角度旋转绘图。</li>
<li><code>save()</code>: 保存当前的绘图状态，包括画笔、画刷、字体等设置。</li>
<li><code>restore()</code>: 恢复上一次保存的绘图状态。</li>
</ul>
<p>  这些方法和属性只是<code>QPainter</code>类的一部分，还有其他许多功能可以用于绘制不同的图形和效果。可以根据需要在<code>QPainter</code>文档中进一步了解更多细节。</p>
<p>  下面是一个简单的示例，演示了如何使用<code>QPainter</code>在窗口上进行绘制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPixmap&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_painter</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    my_painter() &#123;&#125;;</span><br><span class="line">    ~my_painter() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *e)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_painter::paintEvent</span><span class="params">(QPaintEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 消锯齿 */</span></span><br><span class="line">    painter.setRenderHint(QPainter::Antialiasing);</span><br><span class="line">    <span class="comment">/* 设置画笔，线条为红色，线宽为2，使用虚线 */</span></span><br><span class="line">    painter.setPen(QPen(Qt::red , <span class="number">2</span>, Qt::DashLine));</span><br><span class="line">    <span class="comment">/* 设置画刷，当画矩形等封闭图形时，用黄色填充 */</span></span><br><span class="line">    painter.setBrush(Qt::yellow);</span><br><span class="line">    <span class="comment">/* 设置字体，楷体，大小为40，700加粗，斜体 */</span></span><br><span class="line">    painter.setFont(QFont(<span class="string">"楷体"</span>, <span class="number">40</span>, <span class="number">700</span>, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 画直线 */</span></span><br><span class="line">    painter.drawLine(<span class="number">20</span>, <span class="number">40</span>, <span class="number">200</span>, <span class="number">40</span>);</span><br><span class="line">    <span class="comment">/* 画圆 */</span></span><br><span class="line">    painter.drawEllipse(QPoint(<span class="number">100</span>, <span class="number">120</span>), <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="comment">/* 写字 */</span></span><br><span class="line">    painter.drawText(QPoint(<span class="number">20</span>, <span class="number">240</span>), <span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向左移动400 */</span></span><br><span class="line">    painter.translate(<span class="number">400</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 画图片 */</span></span><br><span class="line">    painter.drawPixmap(QPoint(<span class="number">0</span>, <span class="number">20</span>), QPixmap(<span class="string">"./image/滑稽.png"</span>));</span><br><span class="line">    <span class="comment">// /* 画矩形 */</span></span><br><span class="line">    painter.drawRect(QRect(<span class="number">0</span>, <span class="number">120</span>, <span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">    <span class="comment">// /* 画圆角矩形 */</span></span><br><span class="line">    painter.drawRoundedRect(QRect(<span class="number">0</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">50</span>), <span class="number">15</span>, <span class="number">15</span>, Qt::AbsoluteSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">	my_painter widget;</span><br><span class="line">	widget.show();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在上述示例中，我们创建了一个自定义的<code>QWidget</code>派生类<code>my_painter</code>，并重写了<code>paintEvent()</code>函数。在<code>paintEvent()</code>函数中，我们创建了一个<code>QPainter</code>对象，将其关联到窗口上，并使用一些绘制函数，在窗口的矩形区域内绘制图形。最后，我们创建了一个<code>my_painter</code>对象并显示窗口，绘制的图形将在窗口中心显示。运行的结果如下：</p>
<p><img src="/images/learn_note/qt_learn/fig_7.png" alt="" /></p>
<p>  这只是一个简单的示例，你可以根据需要使用其他绘图函数和属性来绘制更复杂的图形和效果。</p>
<h2 id="事件"><a class="markdownIt-Anchor" href="#事件"></a> 事件</h2>
<p>  抄了大佬的这篇<a href="https://blog.csdn.net/qq_29912325/article/details/117767972" target="_blank" rel="noopener">博客</a></p>
<h3 id="事件定义"><a class="markdownIt-Anchor" href="#事件定义"></a> 事件定义</h3>
<p>  事件(event)是由系统或者 Qt 本身在不同的时刻发出的。当用户按下鼠标，敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件是在对用户操作做出响应的时候发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。</p>
<h3 id="事件与信号槽"><a class="markdownIt-Anchor" href="#事件与信号槽"></a> 事件与信号槽</h3>
<p>  一般来说，使用 Qt 编程时，我们并不会把主要精力放在事件上，因为在 Qt 中，需要我们关心的事件总会发出一个信号。比如，我们关心的是<code>QPushButton</code>的鼠标点击，但我们不需要关心这个鼠标点击事件，而是关心它的<code>clicked()</code>信号。</p>
<ul>
<li><strong>信号槽</strong>：<code>signal</code>由具体对象发出，然后会马上交给由<code>connect</code>函数连接的<code>slot</code>进行处理。</li>
<li><strong>事件</strong>：Qt 使用一个事件队列对所有发出的事件进行维护，当新的事件产生时，会被追加到事件队列的尾部，前一个事件完成后，取出后面的事件进行处理。但是，必要的时候，Qt 的事件也是可以不进入事件队列，而是直接处理的。并且，事件还可以使用“事件过滤器”进行过滤。</li>
</ul>
<p>  总的来说，如果我们使用组件，我们关心的是信号槽；如果我们自定义组件，我们关心的是事件。因为我们可以通过事件来改变组件的默认操作。比如，如果我们要自定义一个<code>QPushButton</code>，那么我们就需要重写它的鼠标点击事件和键盘处理事件，并且在恰当的时候发出<code>clicked()</code>信号。</p>
<h3 id="事件循环"><a class="markdownIt-Anchor" href="#事件循环"></a> 事件循环</h3>
<p>  我们在 main 函数里面创建了一个<code>QApplication</code>对象，然后调用了它的<code>exec()</code>函数。其实，这个函数就是开始 Qt 的事件循环。在执行<code>exec()</code>函数之后，程序将进入事件循环来监听应用程序的事件。</p>
<h3 id="事件处理函数"><a class="markdownIt-Anchor" href="#事件处理函数"></a> 事件处理函数</h3>
<p>  当事件发生时，Qt 将创建一个事件对象。Qt 的所有事件都继承于<code>QEvent</code>类。在事件对象创建完毕后，Qt 将这个事件对象传递给 QObject 的<code>event()</code>函数。<code>event()</code>函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数(event handler) 。</p>
<p>  例如在所有组件的父类 QWidget 中，定义了很多事件处理函数 ，如<code>keyPressEvent()</code>、<code>keyReleaseEvent()</code>、<code>mouseDoubleClickEvent()</code>、<code>mouseMoveEvent ()</code>、<code>mousePressEvent()</code>、<code>mouseReleaseEvent()</code>等。这些函数都是<code>protected virtual</code>的，也就是说，我们应该在子类中重写这些函数。下面是一个重写事件处理函数的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMouseEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QKeyEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">event_widget</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">/* 事件处理主函数，主要用来截取事件 */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">event</span><span class="params">(QEvent *ev)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 鼠标按下事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *ev)</span></span>;</span><br><span class="line">    <span class="comment">/* 鼠标释放事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *ev)</span></span>;</span><br><span class="line">    <span class="comment">/* 鼠标移动事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *ev)</span></span>;</span><br><span class="line">    <span class="comment">/* 鼠标双击事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mouseDoubleClickEvent</span><span class="params">(QMouseEvent *ev)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 键盘按下事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent *ev)</span></span>;</span><br><span class="line">    <span class="comment">/* 键盘释放事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">keyReleaseEvent</span><span class="params">(QKeyEvent *ev)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 窗口隐藏事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hideEvent</span><span class="params">(QHideEvent *ev)</span></span>;</span><br><span class="line">    <span class="comment">/* 窗口显示事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showEvent</span><span class="params">(QShowEvent *ev)</span></span>;</span><br><span class="line">    <span class="comment">/* 重绘事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *ev)</span></span>;</span><br><span class="line">    <span class="comment">/* 窗口关闭事件处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">closeEvent</span><span class="params">(QCloseEvent *ev)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事件处理主函数，主要用于事件的分发 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">event_widget::event</span><span class="params">(QEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 默认的事件处理函数 */</span></span><br><span class="line">    <span class="keyword">return</span> QWidget::event(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鼠标按下事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::mousePressEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"mouse press event"</span>;</span><br><span class="line">    QWidget::mousePressEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鼠标释放事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::mouseReleaseEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"mouse release event"</span>;</span><br><span class="line">    QWidget::mouseReleaseEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鼠标移动事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::mouseMoveEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 只有鼠标按下时移动，才能触发事件 */</span></span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"mouse move "</span> &lt;&lt; i++;</span><br><span class="line">    <span class="comment">/* 如果要在鼠标不按下时，也触发事件，需要在构造函数中运行下面的代码 */</span></span><br><span class="line">    <span class="comment">// this-&gt;setMouseTracking(true);</span></span><br><span class="line">    QWidget::mouseMoveEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鼠标双击事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::mouseDoubleClickEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"mouse double click event"</span>;</span><br><span class="line">    QWidget::mouseDoubleClickEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 键盘按下事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::keyPressEvent</span><span class="params">(QKeyEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"key press event "</span> &lt;&lt; ev-&gt;key();</span><br><span class="line">    QWidget::keyPressEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 键盘释放事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::keyReleaseEvent</span><span class="params">(QKeyEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"key release event "</span> &lt;&lt; ev-&gt;key();</span><br><span class="line">    QWidget::keyPressEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 窗口隐藏事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::hideEvent</span><span class="params">(QHideEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"hide event"</span>;</span><br><span class="line">    QWidget::hideEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 窗口显示事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::showEvent</span><span class="params">(QShowEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"show event"</span>;</span><br><span class="line">    QWidget::showEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重绘事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::paintEvent</span><span class="params">(QPaintEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"paint event"</span>;</span><br><span class="line">    QWidget::paintEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 窗口关闭事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::closeEvent</span><span class="params">(QCloseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"close event"</span>;</span><br><span class="line">    QWidget::closeEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    event_widget widget;</span><br><span class="line">    widget.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们定义了一个<code>QWidget</code>的子类<code>event_widget</code>，重写了一些事件处理函数。</p>
<h3 id="事件接受与忽略"><a class="markdownIt-Anchor" href="#事件接受与忽略"></a> 事件接受与忽略</h3>
<p>  前面的例子中我们在重写事件处理函数时，都会调用父类对应的事件处理函数。这在某种程度上说，是把事件向上传递给父类去响应，也就是说，我们在子类中“忽略”了这个事件。</p>
<p>  我们可以把 Qt 的事件传递看成链状：如果子类没有处理这个事件，就会继续向其他类传递。其实，Qt 的事件对象都有一个<code>accept()</code>函数和<code>ignore()</code>函数。正如它们的名字，前者用来告诉 Qt，事件处理函数“接收”了这个事件，不要再传递；后者则告诉 Qt，事件处理函数“忽略”了这个事件，需要继续传递，寻找另外的接受者。在事件处理函数中，可以使用<code>isAccepted()</code>来查询这个事件是不是已经被接收了。</p>
<p>  事实上，我们很少使用<code>accept()</code>和<code>ignore()</code>函数，而是像上面的示例一样，如果希望忽略事件，只要调用父类的响应函数即可。</p>
<p>  Qt 中的事件大部分是<code>protected</code>的，因此，重写的函数必定存在着其父类中的响应函数，这个方法是可行的。为什么要这么做呢？因为我们无法确认父类中的这个处理函数没有操作，如果我们在子类中直接忽略事件，Qt 不会再去寻找其他的接受者，那么父类的操作也就不能进行，这可能会有潜在的危险。</p>
<p>  在一个情形下，我们必须使用<code>accept()</code>和<code>ignore()</code>函数，那就是在窗口关闭的时候。如果在窗口关闭时需要有个询问对话框，那么就需要这么去写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 窗口关闭事件处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_widget::closeEvent</span><span class="params">(QCloseEvent * event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QMessageBox::StandardButton ret;</span><br><span class="line">    ret = QMessageBox::question(<span class="keyword">this</span>, <span class="string">"Quit"</span>,</span><br><span class="line">        <span class="string">"Are you sure to quit this application"</span>,</span><br><span class="line">        QMessageBox::Yes | QMessageBox::No, QMessageBox::No);</span><br><span class="line">    <span class="keyword">if</span>(ret == QMessageBox::Yes) &#123;</span><br><span class="line">        event-&gt;accept();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event-&gt;ignore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们经过询问之后才能正常退出程序。</p>
<h3 id="event函数"><a class="markdownIt-Anchor" href="#event函数"></a> event()函数</h3>
<p>  事件对象创建完毕后，Qt 将这个事件对象传递给<code>QObject</code>的<code>event()</code>函数。<code>event()</code>函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器(event handler)。</p>
<p>  <code>event()</code>函数主要用于事件的分发，所以，如果希望在事件分发之前做一些操作，那么，就需要注意这个<code>event()</code>函数了。为了达到这种目的，我们可以重写<code>event()</code>函数。</p>
<p>  例如，如果希望在窗口中的 tab 键按下时将焦点移动到下一组件，而不是让具有焦点的组件处理，那么就可以继承 QWidget ，并重写它的<code>event()</code>函数，以达到这个目的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MyWidget::event</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;type() == QEvent::KeyPress)</span><br><span class="line">    &#123;</span><br><span class="line">        QKeyEvent *keyEvent = <span class="keyword">static_cast</span>&lt;QKeyEvent *&gt;(event);</span><br><span class="line">        <span class="keyword">if</span> (keyEvent-&gt;key() == Qt::Key_Tab)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理 Tab 键时事件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::event(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <code>event()</code>函数接受一个 QEvent 对象，也就是需要这个函数进行转发的对象。为了进行转发，必定需要有一系列的类型判断，这就可以调用 QEvent 的<code>type()</code>函数，其返回值是<code>QEvent::Type</code>类型的枚举。</p>
<p>  我们处理过自己需要的事件后，可以直接<code>return </code>回去，对于其他我们不关心的事件，需要调用父类的<code>event()</code>函数继续转发，否则这个组件就只能处理我们定义的事件了。</p>
<p>  <code>event()</code>函数返回值是<code>bool</code>类型，如果传入的事件已被识别并且处理，返回<code>true</code>，否则返回<code>false</code>。如果返回值是<code>true</code>，QApplication 会认为这个事件已经处理完毕，会继续处理事件队列中的下一事件；如果返回值是<code>false</code>，QApplication 会尝试寻找这个事件的下一个处理函数。</p>
<p>  <code>event()</code>函数的返回值和事件的<code>accept()</code>和<code>ignore()</code>函数不同。<code>accept()</code>和<code>ignore()</code>函数用于不同的事件处理器之间的沟通，例如判断这一事件是否处理；<code>event()</code>函数的返回值主要是通知 QApplication 的<code>notify()</code>函数是否处理下一事件。</p>
<p>为了更加明晰这一点，我们来看看 QWidget 的<code>event()</code>函数是如何定义的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QWidget::event</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (e-&gt;type())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> QEvent::KeyPress:</span><br><span class="line">            keyPressEvent((QKeyEvent *)event);</span><br><span class="line">            <span class="keyword">if</span> (!((QKeyEvent *)event)-&gt;isAccepted())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QEvent::KeyRelease:</span><br><span class="line">            keyReleaseEvent((QKeyEvent *)event);</span><br><span class="line">            <span class="keyword">if</span> (!((QKeyEvent *)event)-&gt;isAccepted())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// more...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  QWidget 的<code>event()</code>函数使用一个巨大的 switch 来判断 QEvent 的 type，并且分发给不同的事件处理函数。在事件处理函数之后，使用这个事件的<code>isAccepted()</code>方法，获知这个事件是不是被接受，如果没有被接受则<code>event()</code>函数立即返回<code>false</code>，否则返回<code>true</code>。</p>
<p>  另外一个必须重写<code>event()</code>函数的情形是有自定义事件的时候。如果程序中有自定义事件，则必须重写<code>event()</code>函数以便将自定义事件进行分发，否则自定义事件永远也不会被调用。</p>
<h3 id="事件过滤器"><a class="markdownIt-Anchor" href="#事件过滤器"></a> 事件过滤器</h3>
<p>  Qt 创建了 QEvent 事件对象之后，会调用 QObject 的<code>event()</code>函数做事件的分发。有时候，可能需要在调用event()函数之前做一些另外的操作，比如，对话框上某些组件可能并不需要响应回车按下的事件，此时，就需要重新定义组件的<code>event()</code>函数。如果组件很多，就需要重写很多次<code>event()</code>函数，这显然没有效率。为此，可以使用一个事件过滤器，来判断是否需要调用<code>event()</code>函数。</p>
<p>QOjbect 有一个<code>eventFilter()</code>函数，用于建立事件过滤器。这个函数的签名如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">QObject::eventFilter</span><span class="params">(QObject * watched, QEvent * event)</span></span></span><br></pre></td></tr></table></figure>
<p>如果 watched 对象安装了事件过滤器，这个函数会被调用并进行事件过滤，然后才轮到组件进行事件处理。在重写这个函数时，如果需要过滤掉某个事件，例如停止对这个事件的响应，需要返回true。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 重载消息过滤器 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">event_filter_t::eventFilter</span><span class="params">(QObject *o, QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;type() == QEvent::MouseButtonPress ||</span><br><span class="line">        e-&gt;type() == QEvent::MouseButtonRelease ||</span><br><span class="line">        e-&gt;type() == QEvent::MouseButtonDblClick)</span><br><span class="line">    &#123;</span><br><span class="line">		QPushButton *button = <span class="keyword">static_cast</span>&lt;QPushButton *&gt;(o);</span><br><span class="line">        qDebug() &lt;&lt; button-&gt;text() &lt;&lt; <span class="string">"button mouse event"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QObject::eventFilter(o, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  上面的例子中为 event_filter_t 建立了一个事件过滤器。为了过滤某个组件上的事件，首先需要判断这个对象是哪个组件，然后判断这个事件的类型。</p>
<p>  例如，我不想让 textEdit 组件处理键盘事件，于是就首先找到这个组件，如果这个事件是键盘事件，则直接返回<code>true</code>，也就是过滤掉了这个事件。对于其他组件，我们并不保证是不是还有过滤器，于是最保险的办法是调用父类的函数。</p>
<p>  在创建了过滤器之后，下面要做的是安装这个过滤器。安装过滤器需要调用<code>installEventFilter()</code>函数。这个函数的签名如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QObject::installEventFilter</span><span class="params">(QObject* filterObj)</span></span></span><br></pre></td></tr></table></figure>
<p>  这个函数是 QObject 的一个函数，因此可以安装到任何 QObject 的子类，并不仅仅是 UI 组件。这个函数接收一个 QObject 对象，调用了这个函数安装事件过滤器的组件会调用 filterObj 定义的<code>eventFilter()</code>函数。</p>
<p>  例如，<code>textField.installEventFilter(obj)</code>，则如果有事件发送到 textField 组件是，会先调用<code>obj-&gt;eventFilter()</code>函数，然后才会调用<code>textField.event()</code>。</p>
<p>  当然，你也可以把事件过滤器安装到 QApplication 上面，这样就可以过滤所有的事件，已获得更大的控制权。不过，这样做的后果就是会降低事件分发的效率。</p>
<p>  如果一个组件安装了多个过滤器，则最后一个安装的会最先调用，类似于堆栈的行为。</p>
<p>  <strong>注意</strong>：如果你在事件过滤器中<code>delete</code>了某个接收组件，务必将返回值设为<code>true</code>。否则，Qt 还是会将事件分发给这个接收组件，从而导致程序崩溃。</p>
<p>  事件过滤器和被安装的组件必须在同一线程，否则，过滤器不起作用。另外，如果在 install 之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</p>
<p>  事件的调用最终都会调用 QCoreApplication 的<code>notify()</code>函数，因此，最大的控制权实际上是重写 QCoreApplication 的<code>notify()</code>函数。由此可以看出，Qt 的事件处理实际上是分层五个层次：</p>
<ol>
<li>重定义事件处理函数</li>
<li>重定义 event()函数</li>
<li>为单个组件安装事件过滤器</li>
<li>为 QApplication 安装事件过滤器</li>
<li>重定义 QCoreApplication 的<code>notify()</code>函数</li>
</ol>
<p>这几个层次的控制权是逐层增大的。</p>
<h3 id="自定义事件"><a class="markdownIt-Anchor" href="#自定义事件"></a> 自定义事件</h3>
<p>  Qt 允许创建自己的事件类型，这在多线程的程序中尤其有用，当然，也可以用在单线程的程序中，作为一种对象间通讯的机制。那么，为什么需要使用事件，而不是使用信号槽呢？主要原因是，事件的分发既可以是同步的，又可以是异步的，而函数的调用或者说是槽的回调总是同步的。事件的另外一个好处是，它可以使用过滤器。</p>
<p>  Qt 中的自定义事件很简单，同其他类似的库的使用很相似，都是要继承一个类进行扩展。在 Qt 中，你需要继承的类是<code>QEvent</code>。</p>
<p>  继承 QEvent 类，你需要提供一个<code>QEvent::Type</code>类型的参数，作为自定义事件的类型值。这里的 QEvent::Type 类型是 QEvent 里面定义的一个 enum，因此，你是可以传递一个 int 的。重要的是，你的事件类型不能和已经存在的 type 值重复，否则会有不可预料的错误发生！因为系统会将你的事件当做系统事件进行派发和调用。</p>
<p>  在 Qt 中，系统将保留<code>0 - 999</code>的值，也就是说，你的事件 type 要大于999. 具体来说，你的自定义事件的 type 要在 QEvent::User 和 QEvent::MaxUser 的范围之间。其中，QEvent::User 值是1000，QEvent::MaxUser 的值是65535。从这里知道，你最多可以定义64536个事件，相信这个数字已经足够大了！</p>
<p>  但是，即便如此，也只能保证用户自定义事件不能覆盖系统事件，并不能保证自定义事件之间不会被覆盖。为了解决这个问题，Qt 提供了一个函数：<code>registerEventType()</code>，用于自定义事件的注册。该函数签名如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">QEvent::registerEventType</span><span class="params">(<span class="keyword">int</span> hint = <span class="number">-1</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数是 static 的，因此可以使用 QEvent 类直接调用。函数接受一个 int 值，其默认值为-1，返回值是创建的这个 Type 类型的值。如果 hint 是合法的，不会发生任何覆盖，则会返回这个值；如果hint不合法，系统会自动分配一个合法值并返回。因此，使用这个函数即可完成 type 值的指定。这个函数是线程安全的，因此不必另外添加同步。</p>
<p>  你可以在 QEvent 子类中添加自己的事件所需要的数据，然后进行事件的发送。Qt 中提供了两种发送方式：</p>
<p><code>static bool QCoreApplication::sendEvent(QObjecy receiver, QEvent event)</code>：事件被<br />
QCoreApplication 的 notify()函数直接发送给 receiver 对象，返回值是事件处理函数的返回值。使用这个函数必须要在栈上创建事件对象，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMouseEvent <span class="title">event</span><span class="params">(QEvent::MouseButtonPress, pos, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">QApplication::sendEvent(mainWindow, &amp;event);</span><br></pre></td></tr></table></figure>
<p><code>static bool QCoreApplication::postEvent(QObject receiver, QEvent event)</code>：事件被<br />
QCoreApplication 追加到事件列表的最后，并等待处理，该函数将事件追加后会立即返回，并且注意，该函数是线程安全的。另外一点是，使用这个函数必须要在堆上创建对象，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QApplication::postEvent(object, <span class="keyword">new</span> MyEvent(QEvent::registerEventType(<span class="number">2048</span>)));</span><br></pre></td></tr></table></figure>
<p>  这个对象不需要手动 delete，Qt 会自动 delete 掉！因此，如果在 post 事件之后调用 delete，程序可能会崩溃。另外，postEvent()函数还有一个重载的版本，增加一个优先级参数，具体请参见API。通过调用 sendPostedEvent()函数可以让已提交的事件立即得到处理。</p>
<p>  如果要处理自定义事件，可以重写 QObject 的<code>customEvent()</code>函数，该函数接收一个 QEvent 对象作为参数，也可以像前面介绍的重写<code>event()</code>函数的方法去重写这个函数，这两种办法都是可行的。下面是一个使用自定义信号的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化自定义的事件类型值 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> CUSTOM_EVENT_TYPE = QEvent::registerEventType();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义事件类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">custom_event_t</span> :</span> <span class="keyword">public</span> QEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">custom_event_t</span>() : QEvent((QEvent::Type)CUSTOM_EVENT_TYPE) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">main_widgt_t</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">main_widgt_t</span>() : QWidget() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">event</span><span class="params">(QEvent *e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">customEvent</span><span class="params">(QEvent *e)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重载事件处理函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">main_widgt_t::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e-&gt;type() == CUSTOM_EVENT_TYPE)</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"event() get custom event\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QObject::event(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重载自定义事件处理函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main_widgt_t::customEvent</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e-&gt;type() == CUSTOM_EVENT_TYPE)</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"customEvent() get custom event\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">	<span class="keyword">main_widgt_t</span> main_w;</span><br><span class="line"></span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"CUSTOM_EVENT_TYPE: "</span> &lt;&lt; CUSTOM_EVENT_TYPE;</span><br><span class="line"></span><br><span class="line">	<span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">"send custom event"</span>)</span></span>;</span><br><span class="line">	button.setParent(&amp;main_w);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使用lambda表达式连接button的点击事件 */</span></span><br><span class="line">	QObject::connect(&amp;button, &amp;QPushButton::clicked, [&amp;main_w]()</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">custom_event_t</span> custom_event;</span><br><span class="line">        <span class="comment">/* 给main_w发送自定义事件 */</span></span><br><span class="line">        QApplication::sendEvent(&amp;main_w, &amp;custom_event);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	main_w.show();</span><br><span class="line">	<span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="信号和槽"><a class="markdownIt-Anchor" href="#信号和槽"></a> 信号和槽</h2>
<p>  抄了大佬的这篇<a href="https://zhuanlan.zhihu.com/p/648165514" target="_blank" rel="noopener">博客</a>。</p>
<h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3>
<p>  信号槽是QT中用于对象间通信的一种机制，也是QT的核心机制。在GUI编程中，我们经常需要在改变一个组件的同时，通知另一个组件做出响应。</p>
<p>  早期，对象间的通信采用回调来实现。回调实际上是利用函数指针来实现，当我们希望某件事发生时处理函数能够获得通知，就需要将回调函数的指针传递给处理函数，这样处理函数就会在合适的时候调用回调函数。回调有两个明显的缺点：</p>
<ul>
<li>它们不是类型安全的，我们无法保证处理函数传递给回调函数的参数都是正确的。</li>
<li>回调函数和处理函数紧密耦合，源于处理函数必须知道哪一个函数被回调。</li>
</ul>
<p>  在QT中，我们有回调技术之外的选择，也即是信号槽机制。所谓的信号与槽，其实都是函数。当特定事件被触发时将发送一个信号，而与该信号建立的连接槽，则可以接收到该信号并做出反应。</p>
<p>  QT组件预定义了很多信号和槽，而在GUI编程中，我们习惯于继承那些组件，继承后添加我们自己的槽，以便以我们的方式来处理信号。槽和普通的C++成员函数几乎是一样的，它可以是虚函数，可以被重载，可以是共有、私有或是保护的，也同样可以被其他成员函数调用。它的函数参数也可以是任意类型的。唯一不同的是：槽还可以和信号连接在一起。</p>
<p>  与回调不同，信号槽机制是类型安全的。这体现在信号的函数签名与槽的函数签名必须匹配上，才能够发生信号的传递。实际上，槽的参数个数可以比信号的参数个数少，因为槽能够忽略信号形参中多出来的参数。信号和槽是松耦合的：发出信号的类不关心哪些类将接收它的信号。QT的槽能够接收到信号的参数并调用，信号和槽都可以有任意个数的参数，它们都是类型安全的。</p>
<h3 id="样例分析"><a class="markdownIt-Anchor" href="#样例分析"></a> 样例分析</h3>
<p>  首先我们要知道的是，所有继承自<code>QObject</code>或者它的子类（如<code>QWidget</code>）都可以包含信号槽。我们写的类也要继承自<code>QObject</code>（或其子类）。所有包含了信号和槽的类都必须在声明的上部含有<code>Q_OBJECT</code>宏。</p>
<p>下面是一个样例，一个定义了信号的类和一个定义了槽函数的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MY_SIGHNAL_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MY_SIGHNAL_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 一个定义了信号的类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_signal</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    my_signal(<span class="keyword">int</span> id_) : QObject(), _id(id_) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_id</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">/* 信号 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">int</span> num = <span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __MY_SIGHNAL_H__ */</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MY_SLOT_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MY_SLOT_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_signal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 一个定义了槽函数的类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_slot</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    my_slot(<span class="keyword">int</span> id_) : QObject(), _id(id_) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_id</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="comment">/* 槽函数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">slot_fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		my_signal *sign = <span class="keyword">static_cast</span>&lt;my_signal *&gt;(sender());</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"my_slot: "</span> &lt;&lt; get_id()</span><br><span class="line">                 &lt;&lt; <span class="string">" get my_sign: "</span> &lt;&lt; sign-&gt;get_id()</span><br><span class="line">                 &lt;&lt; <span class="string">" str: "</span> &lt;&lt; str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __MY_SLOT_H__ */</span></span></span><br></pre></td></tr></table></figure>
<p>  在这个信号类中，我们使用Qt的<code>signals</code>保留字定义了一个信号函数<code>signal_fun()</code>，<code>signal_fun()</code>的代码会由 Qt 的 moc 工具自动生成，开发人员一定不能在自己的C++代码中实现它。反之，槽应该由开发人员来实现，在槽函数里可以使用<code>sender()</code>来获取信号的发送方。需要注意的是，必须在 pro 工程文件里，使用<code>HEADERS</code>添加定义了信号或槽函数类的头文件，如果只是使用<code>INCLUDEPATH</code>添加头文件的路径，Qt 不会调用 moc 生成代码。</p>
<p>  可以使用<code>QObject::connect()</code>函数连接信号和槽，该函数指定了信号发送方、信号函数、信号接收方、槽函数等信息，函数的格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect(</span><br><span class="line">    QObject* sender,      <span class="comment">/* 信号发送方 */</span></span><br><span class="line">    SIGNAL(signal_fun()), <span class="comment">/* 信号函数 */</span></span><br><span class="line">    QObject* receiver,    <span class="comment">/* 信号接收方 */</span></span><br><span class="line">    SLOT(slot_fun()));    <span class="comment">/* 槽函数 */</span></span><br></pre></td></tr></table></figure>
<p>  最后，我们可以使用 Qt 的<code>emit</code>关键字发送信号，下面是一个使用<code>connect()</code>和<code>emit</code>的简单样例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_signal.h"</span> <span class="comment">/* 定义了信号的类 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_slot.h"</span>   <span class="comment">/* 定义了槽函数的类 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">QCoreApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">my_signal <span class="title">sign</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">/* 信号发送方 */</span></span><br><span class="line">    <span class="function">my_slot <span class="title">slot</span><span class="params">(<span class="number">1</span>)</span></span>;   <span class="comment">/* 信号接收方 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 连接信号和槽 */</span></span><br><span class="line">    QObject::connect(&amp;sign, SIGNAL(signal_fun(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>)),</span><br><span class="line">                     &amp;slot, SLOT(slot_fun(<span class="keyword">const</span> <span class="keyword">char</span> *)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送信号 */</span></span><br><span class="line">    emit sign.signal_fun(<span class="string">"hello word 1"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  上面的例子中，信号函数有两个参数，而槽函数只有一个参数，信息函数的第二个参数会被槽函数忽略。这个例子展示了对象之间通信的一种方式。对象间可以一起工作，而不需要知道彼此的任何信息。为了达到通信的目的，只需要将它们连接起来，而这只需要通过调用<code>QObject::connect()</code>函数指定一些简单信息就好。</p>
<h3 id="连接"><a class="markdownIt-Anchor" href="#连接"></a> 连接</h3>
<p>要把信号成功连接到槽，它们的参数必须具有相同的顺序和相同的类型，或者允许信号的参数比槽多，槽会自动忽略掉多出来的参数而进行调用。</p>
<h4 id="一个信号可以连接多个槽"><a class="markdownIt-Anchor" href="#一个信号可以连接多个槽"></a> 一个信号可以连接多个槽</h4>
<p>  使用<code>QObject::connect</code>可以把一个信号连接到多个槽，而当信号发射时，将按声明联系时的顺序依次调用槽。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my_signal sign;</span><br><span class="line">my_slot slot_1, slot_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号连接到两个槽 */</span></span><br><span class="line">QObject::connect(&amp;sign, SIGNAL(signal_fun(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>)), </span><br><span class="line">                 &amp;slot_1, SLOT(slot_fun(<span class="keyword">const</span> <span class="keyword">char</span> *)));</span><br><span class="line">QObject::connect(&amp;sign, SIGNAL(signal_fun(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>)),</span><br><span class="line">                 &amp;slot_2, SLOT(slot_fun(<span class="keyword">const</span> <span class="keyword">char</span> *)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发送信号 */</span></span><br><span class="line">emit sign.signal_fun(<span class="string">"hello word"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 依次调用 slot_1.slot_fun()、slot_2.slot_fun() */</span></span><br></pre></td></tr></table></figure>
<h4 id="多个信号可以连接同一个槽"><a class="markdownIt-Anchor" href="#多个信号可以连接同一个槽"></a> 多个信号可以连接同一个槽</h4>
<p>  同样的，可以让多个信号连接到同一个槽上，而且其中的任意一个信号的发送，都会调用了那个槽。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my_signal sign_1, sign_2;</span><br><span class="line">my_slot slot;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 两个信号连接到同一个槽上 */</span></span><br><span class="line">QObject::connect(&amp;sign_1, SIGNAL(signal_fun(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>)),</span><br><span class="line">                 &amp;slot, SLOT(slot_fun(<span class="keyword">const</span> <span class="keyword">char</span> *)));</span><br><span class="line">QObject::connect(&amp;sign_2, SIGNAL(signal_fun(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>)),</span><br><span class="line">                 &amp;slot, SLOT(slot_fun(<span class="keyword">const</span> <span class="keyword">char</span> *)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发送信号，两个信号都会触发槽函数slot.slot_fun()的调用 */</span></span><br><span class="line">emit sign_1.signal_fun(<span class="string">"hello word 1"</span>, <span class="number">1</span>);</span><br><span class="line">emit sign_2.signal_fun(<span class="string">"hello word 2"</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h4 id="一个信号可以和另外一个信号相连接"><a class="markdownIt-Anchor" href="#一个信号可以和另外一个信号相连接"></a> 一个信号可以和另外一个信号相连接</h4>
<p>  当发送第一个信号的时候，也会把第二个信号发送出去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">my_signal sign_1, sign_2;</span><br><span class="line">my_slot slot;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 两个信息号相连 */</span></span><br><span class="line">QObject::connect(&amp;sign_1, SIGNAL(signal_fun(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>)),</span><br><span class="line">                 &amp;sign_2, SIGNAL(signal_fun(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>)));</span><br><span class="line"><span class="comment">/* 两个信号连接到同一个槽上 */</span></span><br><span class="line">QObject::connect(&amp;sign_1, SIGNAL(signal_fun(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>)),</span><br><span class="line">                 &amp;slot, SLOT(slot_fun(<span class="keyword">const</span> <span class="keyword">char</span> *)));</span><br><span class="line">QObject::connect(&amp;sign_2, SIGNAL(signal_fun(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>)),</span><br><span class="line">                 &amp;slot, SLOT(slot_fun(<span class="keyword">const</span> <span class="keyword">char</span> *)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发送信号1，信号2也会发送出去 */</span></span><br><span class="line">emit sign_1.signal_fun(<span class="string">"hello word 1"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 发送信号2，信号1不会被发送出去 */</span></span><br><span class="line">emit sign_2.signal_fun(<span class="string">"hello word 2"</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h4 id="连接可以被移除"><a class="markdownIt-Anchor" href="#连接可以被移除"></a> 连接可以被移除</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 移除sign.signal_fun()与slot.slot_fun()之间的连接 */</span></span><br><span class="line">QObject::disconnect(&amp;sign, SIGNAL(signal_fun(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>)),</span><br><span class="line">                    &amp;slot, SLOT(slot_fun(<span class="keyword">const</span> <span class="keyword">char</span> *)));</span><br></pre></td></tr></table></figure>
<p>  实际上当对象被delete时，其关联的所有连接都会失效，QT会自动移除和这个对象的所有连接。</p>

      
    </div>
    
    
    
    
    

    
	  <hr>
      <div class="post-share">分享到：</div>
    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Qt/" rel="tag"># Qt</a>
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/learn_note/huffman_tree/" rel="next" title="哈夫曼树">
                <i class="fa fa-chevron-left"></i> 哈夫曼树
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="waline"></div>
    </div>
    
    <link rel="stylesheet" href="https://unpkg.com/@waline/client@v3/dist/waline.css" />
    <script  type="module">
        import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js';

        const waline = init({
            el: '#waline',
            serverURL: 'https://waline-pi-hazel.vercel.app',
            emoji: [
                '//unpkg.com/@waline/emojis@1.2.0/qq',
                '//unpkg.com/@waline/emojis@1.2.0/bmoji',
                '//unpkg.com/@waline/emojis@1.2.0/bilibili',
            ],
        });
    </script>
    <style>
        /*设置 Waline 的主题色*/
        :root{
            --waline-bg-color: #fff0;
            --waline-bg-color-light: #fff0;
        }
        #waline {
            padding: 2em;
        }
    </style>


  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/ganyuo.png"
                alt="ganyuo" />
            
              <p class="site-author-name" itemprop="name">ganyuo's blog</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/ganyuo" target="_blank" title="GitHub" data-balloon="GitHub" data-balloon-pos="up">
                    
                      <i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto://ganyuo@outlook.com" target="_blank" title="Mail" data-balloon="Mail" data-balloon-pos="up">
                    
                      <i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
            
          </div>

          

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            
            

          </nav>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#先说两句"><span class="nav-number">1.</span> <span class="nav-text"> 先说两句</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#qt简介"><span class="nav-number">2.</span> <span class="nav-text"> Qt简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#环境搭建"><span class="nav-number">3.</span> <span class="nav-text"> 环境搭建</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#pro文件配置"><span class="nav-number">4.</span> <span class="nav-text"> pro文件配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常用配置项"><span class="nav-number">4.1.</span> <span class="nav-text"> 常用配置项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pro文件样例"><span class="nav-number">4.2.</span> <span class="nav-text"> pro文件样例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#gui"><span class="nav-number">5.</span> <span class="nav-text"> GUI</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#qwidget"><span class="nav-number">5.1.</span> <span class="nav-text"> QWidget</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控件"><span class="nav-number">5.2.</span> <span class="nav-text"> 控件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#按钮-qpushbutton"><span class="nav-number">5.2.1.</span> <span class="nav-text"> 按钮-QPushButton</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入框-qlineedit"><span class="nav-number">5.2.2.</span> <span class="nav-text"> 输入框-QLineEdit</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#坐标体系"><span class="nav-number">5.3.</span> <span class="nav-text"> 坐标体系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#layout"><span class="nav-number">5.4.</span> <span class="nav-text"> layout</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简述"><span class="nav-number">5.4.1.</span> <span class="nav-text"> 简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用layout"><span class="nav-number">5.4.2.</span> <span class="nav-text"> 常用layout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为layout添加控件"><span class="nav-number">5.4.3.</span> <span class="nav-text"> 为layout添加控件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伸展因素"><span class="nav-number">5.4.4.</span> <span class="nav-text"> 伸展因素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单的demo"><span class="nav-number">5.4.5.</span> <span class="nav-text"> 简单的demo</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主窗口"><span class="nav-number">5.5.</span> <span class="nav-text"> 主窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#菜单栏"><span class="nav-number">5.5.1.</span> <span class="nav-text"> 菜单栏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工具栏"><span class="nav-number">5.5.2.</span> <span class="nav-text"> 工具栏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#状态栏"><span class="nav-number">5.5.3.</span> <span class="nav-text"> 状态栏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浮动窗口"><span class="nav-number">5.5.4.</span> <span class="nav-text"> 浮动窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中心区域"><span class="nav-number">5.5.5.</span> <span class="nav-text"> 中心区域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统托盘图标"><span class="nav-number">5.5.6.</span> <span class="nav-text"> 系统托盘图标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对话框"><span class="nav-number">5.6.</span> <span class="nav-text"> 对话框</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模态对话框"><span class="nav-number">5.6.1.</span> <span class="nav-text"> 模态对话框</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非模态对话框"><span class="nav-number">5.6.2.</span> <span class="nav-text"> 非模态对话框</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#qt常用的对话框"><span class="nav-number">5.6.3.</span> <span class="nav-text"> Qt常用的对话框</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#消息对话框"><span class="nav-number">5.6.3.1.</span> <span class="nav-text"> 消息对话框</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件对话框"><span class="nav-number">5.6.3.2.</span> <span class="nav-text"> 文件对话框</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#颜色对话框"><span class="nav-number">5.6.3.3.</span> <span class="nav-text"> 颜色对话框</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字体对话框"><span class="nav-number">5.6.3.4.</span> <span class="nav-text"> 字体对话框</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输入对话框"><span class="nav-number">5.6.3.5.</span> <span class="nav-text"> 输入对话框</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#画板"><span class="nav-number">5.7.</span> <span class="nav-text"> 画板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件"><span class="nav-number">5.8.</span> <span class="nav-text"> 事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事件定义"><span class="nav-number">5.8.1.</span> <span class="nav-text"> 事件定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件与信号槽"><span class="nav-number">5.8.2.</span> <span class="nav-text"> 事件与信号槽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件循环"><span class="nav-number">5.8.3.</span> <span class="nav-text"> 事件循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件处理函数"><span class="nav-number">5.8.4.</span> <span class="nav-text"> 事件处理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件接受与忽略"><span class="nav-number">5.8.5.</span> <span class="nav-text"> 事件接受与忽略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#event函数"><span class="nav-number">5.8.6.</span> <span class="nav-text"> event()函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件过滤器"><span class="nav-number">5.8.7.</span> <span class="nav-text"> 事件过滤器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义事件"><span class="nav-number">5.8.8.</span> <span class="nav-text"> 自定义事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号和槽"><span class="nav-number">5.9.</span> <span class="nav-text"> 信号和槽</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简介"><span class="nav-number">5.9.1.</span> <span class="nav-text"> 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#样例分析"><span class="nav-number">5.9.2.</span> <span class="nav-text"> 样例分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接"><span class="nav-number">5.9.3.</span> <span class="nav-text"> 连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一个信号可以连接多个槽"><span class="nav-number">5.9.3.1.</span> <span class="nav-text"> 一个信号可以连接多个槽</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多个信号可以连接同一个槽"><span class="nav-number">5.9.3.2.</span> <span class="nav-text"> 多个信号可以连接同一个槽</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个信号可以和另外一个信号相连接"><span class="nav-number">5.9.3.3.</span> <span class="nav-text"> 一个信号可以和另外一个信号相连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#连接可以被移除"><span class="nav-number">5.9.3.4.</span> <span class="nav-text"> 连接可以被移除</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <!--<div class="footer-image"></div>-->
      <div class="footer-inner">
        <p>
小破站在各种灾难中苟活了
	<span id="since"></span>
	<span class="my-face">o(╥﹏╥)o</span>
	<a href="/atom.xml" target="_blank">RSS</a>
</p>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数 <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量 <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

	<img class="background-image" src="/images/backgound_1.jpg" />

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

	
		<div class="live2d-container">
	<div class="live2d-tips"></div>
	<canvas id="live2d-canvas" height="380" style="width:300px;" ></canvas>
	<div class="live2d-tools">
		<i class="fa fa-commenting"></i>
		<i class="fa fa-chevron-down"></i>
		<i class="fa fa-chevron-up"></i>
	</div>
</div>

<script type="text/javascript" src="/js/live2d.js"></script>
<script type="text/javascript" src="/js/live2d_tools.js"></script>
<script>
	loadlive2d('live2d-canvas', "/images/live2d_model/nepnep/index.json");
</script>

	

    

  </div>

  <script type="text/javascript" src="/js/sagiri.min.js"></script>

  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('2');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

  

</body>
</html>
